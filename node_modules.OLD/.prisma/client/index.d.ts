
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Memorial
 * 
 */
export type Memorial = $Result.DefaultSelection<Prisma.$MemorialPayload>
/**
 * Model Ceremony
 * 
 */
export type Ceremony = $Result.DefaultSelection<Prisma.$CeremonyPayload>
/**
 * Model Reception
 * 
 */
export type Reception = $Result.DefaultSelection<Prisma.$ReceptionPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model MemoryNote
 * 
 */
export type MemoryNote = $Result.DefaultSelection<Prisma.$MemoryNotePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WelcomeScope: {
  OPEN: 'OPEN',
  FAMILY: 'FAMILY',
  PRIVATE: 'PRIVATE'
};

export type WelcomeScope = (typeof WelcomeScope)[keyof typeof WelcomeScope]

}

export type WelcomeScope = $Enums.WelcomeScope

export const WelcomeScope: typeof $Enums.WelcomeScope

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Memorials
 * const memorials = await prisma.memorial.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Memorials
   * const memorials = await prisma.memorial.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.memorial`: Exposes CRUD operations for the **Memorial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memorials
    * const memorials = await prisma.memorial.findMany()
    * ```
    */
  get memorial(): Prisma.MemorialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ceremony`: Exposes CRUD operations for the **Ceremony** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ceremonies
    * const ceremonies = await prisma.ceremony.findMany()
    * ```
    */
  get ceremony(): Prisma.CeremonyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reception`: Exposes CRUD operations for the **Reception** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receptions
    * const receptions = await prisma.reception.findMany()
    * ```
    */
  get reception(): Prisma.ReceptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memoryNote`: Exposes CRUD operations for the **MemoryNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemoryNotes
    * const memoryNotes = await prisma.memoryNote.findMany()
    * ```
    */
  get memoryNote(): Prisma.MemoryNoteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Memorial: 'Memorial',
    Ceremony: 'Ceremony',
    Reception: 'Reception',
    Attendance: 'Attendance',
    MemoryNote: 'MemoryNote'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "memorial" | "ceremony" | "reception" | "attendance" | "memoryNote"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Memorial: {
        payload: Prisma.$MemorialPayload<ExtArgs>
        fields: Prisma.MemorialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemorialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemorialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>
          }
          findFirst: {
            args: Prisma.MemorialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemorialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>
          }
          findMany: {
            args: Prisma.MemorialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>[]
          }
          create: {
            args: Prisma.MemorialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>
          }
          createMany: {
            args: Prisma.MemorialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemorialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>[]
          }
          delete: {
            args: Prisma.MemorialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>
          }
          update: {
            args: Prisma.MemorialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>
          }
          deleteMany: {
            args: Prisma.MemorialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemorialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemorialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>[]
          }
          upsert: {
            args: Prisma.MemorialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemorialPayload>
          }
          aggregate: {
            args: Prisma.MemorialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemorial>
          }
          groupBy: {
            args: Prisma.MemorialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemorialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemorialCountArgs<ExtArgs>
            result: $Utils.Optional<MemorialCountAggregateOutputType> | number
          }
        }
      }
      Ceremony: {
        payload: Prisma.$CeremonyPayload<ExtArgs>
        fields: Prisma.CeremonyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CeremonyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CeremonyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>
          }
          findFirst: {
            args: Prisma.CeremonyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CeremonyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>
          }
          findMany: {
            args: Prisma.CeremonyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>[]
          }
          create: {
            args: Prisma.CeremonyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>
          }
          createMany: {
            args: Prisma.CeremonyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CeremonyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>[]
          }
          delete: {
            args: Prisma.CeremonyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>
          }
          update: {
            args: Prisma.CeremonyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>
          }
          deleteMany: {
            args: Prisma.CeremonyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CeremonyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CeremonyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>[]
          }
          upsert: {
            args: Prisma.CeremonyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CeremonyPayload>
          }
          aggregate: {
            args: Prisma.CeremonyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCeremony>
          }
          groupBy: {
            args: Prisma.CeremonyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CeremonyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CeremonyCountArgs<ExtArgs>
            result: $Utils.Optional<CeremonyCountAggregateOutputType> | number
          }
        }
      }
      Reception: {
        payload: Prisma.$ReceptionPayload<ExtArgs>
        fields: Prisma.ReceptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          findFirst: {
            args: Prisma.ReceptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          findMany: {
            args: Prisma.ReceptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>[]
          }
          create: {
            args: Prisma.ReceptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          createMany: {
            args: Prisma.ReceptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>[]
          }
          delete: {
            args: Prisma.ReceptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          update: {
            args: Prisma.ReceptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          deleteMany: {
            args: Prisma.ReceptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>[]
          }
          upsert: {
            args: Prisma.ReceptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          aggregate: {
            args: Prisma.ReceptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReception>
          }
          groupBy: {
            args: Prisma.ReceptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceptionCountArgs<ExtArgs>
            result: $Utils.Optional<ReceptionCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      MemoryNote: {
        payload: Prisma.$MemoryNotePayload<ExtArgs>
        fields: Prisma.MemoryNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemoryNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemoryNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>
          }
          findFirst: {
            args: Prisma.MemoryNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemoryNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>
          }
          findMany: {
            args: Prisma.MemoryNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>[]
          }
          create: {
            args: Prisma.MemoryNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>
          }
          createMany: {
            args: Prisma.MemoryNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemoryNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>[]
          }
          delete: {
            args: Prisma.MemoryNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>
          }
          update: {
            args: Prisma.MemoryNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>
          }
          deleteMany: {
            args: Prisma.MemoryNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemoryNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemoryNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>[]
          }
          upsert: {
            args: Prisma.MemoryNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryNotePayload>
          }
          aggregate: {
            args: Prisma.MemoryNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemoryNote>
          }
          groupBy: {
            args: Prisma.MemoryNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemoryNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemoryNoteCountArgs<ExtArgs>
            result: $Utils.Optional<MemoryNoteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    memorial?: MemorialOmit
    ceremony?: CeremonyOmit
    reception?: ReceptionOmit
    attendance?: AttendanceOmit
    memoryNote?: MemoryNoteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MemorialCountOutputType
   */

  export type MemorialCountOutputType = {
    notes: number
    attendances: number
  }

  export type MemorialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | MemorialCountOutputTypeCountNotesArgs
    attendances?: boolean | MemorialCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * MemorialCountOutputType without action
   */
  export type MemorialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemorialCountOutputType
     */
    select?: MemorialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemorialCountOutputType without action
   */
  export type MemorialCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryNoteWhereInput
  }

  /**
   * MemorialCountOutputType without action
   */
  export type MemorialCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Memorial
   */

  export type AggregateMemorial = {
    _count: MemorialCountAggregateOutputType | null
    _avg: MemorialAvgAggregateOutputType | null
    _sum: MemorialSumAggregateOutputType | null
    _min: MemorialMinAggregateOutputType | null
    _max: MemorialMaxAggregateOutputType | null
  }

  export type MemorialAvgAggregateOutputType = {
    id: number | null
  }

  export type MemorialSumAggregateOutputType = {
    id: number | null
  }

  export type MemorialMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    birthDate: Date | null
    deathDate: Date | null
    obituaryNote: string | null
    bio: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type MemorialMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    birthDate: Date | null
    deathDate: Date | null
    obituaryNote: string | null
    bio: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type MemorialCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    birthDate: number
    deathDate: number
    obituaryNote: number
    bio: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type MemorialAvgAggregateInputType = {
    id?: true
  }

  export type MemorialSumAggregateInputType = {
    id?: true
  }

  export type MemorialMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    birthDate?: true
    deathDate?: true
    obituaryNote?: true
    bio?: true
    imageUrl?: true
    createdAt?: true
  }

  export type MemorialMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    birthDate?: true
    deathDate?: true
    obituaryNote?: true
    bio?: true
    imageUrl?: true
    createdAt?: true
  }

  export type MemorialCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    birthDate?: true
    deathDate?: true
    obituaryNote?: true
    bio?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type MemorialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memorial to aggregate.
     */
    where?: MemorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memorials to fetch.
     */
    orderBy?: MemorialOrderByWithRelationInput | MemorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memorials
    **/
    _count?: true | MemorialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemorialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemorialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemorialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemorialMaxAggregateInputType
  }

  export type GetMemorialAggregateType<T extends MemorialAggregateArgs> = {
        [P in keyof T & keyof AggregateMemorial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemorial[P]>
      : GetScalarType<T[P], AggregateMemorial[P]>
  }




  export type MemorialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemorialWhereInput
    orderBy?: MemorialOrderByWithAggregationInput | MemorialOrderByWithAggregationInput[]
    by: MemorialScalarFieldEnum[] | MemorialScalarFieldEnum
    having?: MemorialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemorialCountAggregateInputType | true
    _avg?: MemorialAvgAggregateInputType
    _sum?: MemorialSumAggregateInputType
    _min?: MemorialMinAggregateInputType
    _max?: MemorialMaxAggregateInputType
  }

  export type MemorialGroupByOutputType = {
    id: number
    slug: string
    name: string
    birthDate: Date | null
    deathDate: Date | null
    obituaryNote: string | null
    bio: string | null
    imageUrl: string | null
    createdAt: Date
    _count: MemorialCountAggregateOutputType | null
    _avg: MemorialAvgAggregateOutputType | null
    _sum: MemorialSumAggregateOutputType | null
    _min: MemorialMinAggregateOutputType | null
    _max: MemorialMaxAggregateOutputType | null
  }

  type GetMemorialGroupByPayload<T extends MemorialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemorialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemorialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemorialGroupByOutputType[P]>
            : GetScalarType<T[P], MemorialGroupByOutputType[P]>
        }
      >
    >


  export type MemorialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    birthDate?: boolean
    deathDate?: boolean
    obituaryNote?: boolean
    bio?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    ceremony?: boolean | Memorial$ceremonyArgs<ExtArgs>
    reception?: boolean | Memorial$receptionArgs<ExtArgs>
    notes?: boolean | Memorial$notesArgs<ExtArgs>
    attendances?: boolean | Memorial$attendancesArgs<ExtArgs>
    _count?: boolean | MemorialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memorial"]>

  export type MemorialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    birthDate?: boolean
    deathDate?: boolean
    obituaryNote?: boolean
    bio?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["memorial"]>

  export type MemorialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    birthDate?: boolean
    deathDate?: boolean
    obituaryNote?: boolean
    bio?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["memorial"]>

  export type MemorialSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    birthDate?: boolean
    deathDate?: boolean
    obituaryNote?: boolean
    bio?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type MemorialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "birthDate" | "deathDate" | "obituaryNote" | "bio" | "imageUrl" | "createdAt", ExtArgs["result"]["memorial"]>
  export type MemorialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ceremony?: boolean | Memorial$ceremonyArgs<ExtArgs>
    reception?: boolean | Memorial$receptionArgs<ExtArgs>
    notes?: boolean | Memorial$notesArgs<ExtArgs>
    attendances?: boolean | Memorial$attendancesArgs<ExtArgs>
    _count?: boolean | MemorialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemorialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemorialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemorialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Memorial"
    objects: {
      ceremony: Prisma.$CeremonyPayload<ExtArgs> | null
      reception: Prisma.$ReceptionPayload<ExtArgs> | null
      notes: Prisma.$MemoryNotePayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      name: string
      birthDate: Date | null
      deathDate: Date | null
      obituaryNote: string | null
      bio: string | null
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["memorial"]>
    composites: {}
  }

  type MemorialGetPayload<S extends boolean | null | undefined | MemorialDefaultArgs> = $Result.GetResult<Prisma.$MemorialPayload, S>

  type MemorialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemorialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemorialCountAggregateInputType | true
    }

  export interface MemorialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Memorial'], meta: { name: 'Memorial' } }
    /**
     * Find zero or one Memorial that matches the filter.
     * @param {MemorialFindUniqueArgs} args - Arguments to find a Memorial
     * @example
     * // Get one Memorial
     * const memorial = await prisma.memorial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemorialFindUniqueArgs>(args: SelectSubset<T, MemorialFindUniqueArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Memorial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemorialFindUniqueOrThrowArgs} args - Arguments to find a Memorial
     * @example
     * // Get one Memorial
     * const memorial = await prisma.memorial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemorialFindUniqueOrThrowArgs>(args: SelectSubset<T, MemorialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Memorial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemorialFindFirstArgs} args - Arguments to find a Memorial
     * @example
     * // Get one Memorial
     * const memorial = await prisma.memorial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemorialFindFirstArgs>(args?: SelectSubset<T, MemorialFindFirstArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Memorial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemorialFindFirstOrThrowArgs} args - Arguments to find a Memorial
     * @example
     * // Get one Memorial
     * const memorial = await prisma.memorial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemorialFindFirstOrThrowArgs>(args?: SelectSubset<T, MemorialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Memorials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemorialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memorials
     * const memorials = await prisma.memorial.findMany()
     * 
     * // Get first 10 Memorials
     * const memorials = await prisma.memorial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memorialWithIdOnly = await prisma.memorial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemorialFindManyArgs>(args?: SelectSubset<T, MemorialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Memorial.
     * @param {MemorialCreateArgs} args - Arguments to create a Memorial.
     * @example
     * // Create one Memorial
     * const Memorial = await prisma.memorial.create({
     *   data: {
     *     // ... data to create a Memorial
     *   }
     * })
     * 
     */
    create<T extends MemorialCreateArgs>(args: SelectSubset<T, MemorialCreateArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Memorials.
     * @param {MemorialCreateManyArgs} args - Arguments to create many Memorials.
     * @example
     * // Create many Memorials
     * const memorial = await prisma.memorial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemorialCreateManyArgs>(args?: SelectSubset<T, MemorialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memorials and returns the data saved in the database.
     * @param {MemorialCreateManyAndReturnArgs} args - Arguments to create many Memorials.
     * @example
     * // Create many Memorials
     * const memorial = await prisma.memorial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memorials and only return the `id`
     * const memorialWithIdOnly = await prisma.memorial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemorialCreateManyAndReturnArgs>(args?: SelectSubset<T, MemorialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Memorial.
     * @param {MemorialDeleteArgs} args - Arguments to delete one Memorial.
     * @example
     * // Delete one Memorial
     * const Memorial = await prisma.memorial.delete({
     *   where: {
     *     // ... filter to delete one Memorial
     *   }
     * })
     * 
     */
    delete<T extends MemorialDeleteArgs>(args: SelectSubset<T, MemorialDeleteArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Memorial.
     * @param {MemorialUpdateArgs} args - Arguments to update one Memorial.
     * @example
     * // Update one Memorial
     * const memorial = await prisma.memorial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemorialUpdateArgs>(args: SelectSubset<T, MemorialUpdateArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Memorials.
     * @param {MemorialDeleteManyArgs} args - Arguments to filter Memorials to delete.
     * @example
     * // Delete a few Memorials
     * const { count } = await prisma.memorial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemorialDeleteManyArgs>(args?: SelectSubset<T, MemorialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memorials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemorialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memorials
     * const memorial = await prisma.memorial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemorialUpdateManyArgs>(args: SelectSubset<T, MemorialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memorials and returns the data updated in the database.
     * @param {MemorialUpdateManyAndReturnArgs} args - Arguments to update many Memorials.
     * @example
     * // Update many Memorials
     * const memorial = await prisma.memorial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Memorials and only return the `id`
     * const memorialWithIdOnly = await prisma.memorial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemorialUpdateManyAndReturnArgs>(args: SelectSubset<T, MemorialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Memorial.
     * @param {MemorialUpsertArgs} args - Arguments to update or create a Memorial.
     * @example
     * // Update or create a Memorial
     * const memorial = await prisma.memorial.upsert({
     *   create: {
     *     // ... data to create a Memorial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Memorial we want to update
     *   }
     * })
     */
    upsert<T extends MemorialUpsertArgs>(args: SelectSubset<T, MemorialUpsertArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Memorials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemorialCountArgs} args - Arguments to filter Memorials to count.
     * @example
     * // Count the number of Memorials
     * const count = await prisma.memorial.count({
     *   where: {
     *     // ... the filter for the Memorials we want to count
     *   }
     * })
    **/
    count<T extends MemorialCountArgs>(
      args?: Subset<T, MemorialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemorialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Memorial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemorialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemorialAggregateArgs>(args: Subset<T, MemorialAggregateArgs>): Prisma.PrismaPromise<GetMemorialAggregateType<T>>

    /**
     * Group by Memorial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemorialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemorialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemorialGroupByArgs['orderBy'] }
        : { orderBy?: MemorialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemorialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemorialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Memorial model
   */
  readonly fields: MemorialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Memorial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemorialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ceremony<T extends Memorial$ceremonyArgs<ExtArgs> = {}>(args?: Subset<T, Memorial$ceremonyArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reception<T extends Memorial$receptionArgs<ExtArgs> = {}>(args?: Subset<T, Memorial$receptionArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notes<T extends Memorial$notesArgs<ExtArgs> = {}>(args?: Subset<T, Memorial$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Memorial$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Memorial$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Memorial model
   */
  interface MemorialFieldRefs {
    readonly id: FieldRef<"Memorial", 'Int'>
    readonly slug: FieldRef<"Memorial", 'String'>
    readonly name: FieldRef<"Memorial", 'String'>
    readonly birthDate: FieldRef<"Memorial", 'DateTime'>
    readonly deathDate: FieldRef<"Memorial", 'DateTime'>
    readonly obituaryNote: FieldRef<"Memorial", 'String'>
    readonly bio: FieldRef<"Memorial", 'String'>
    readonly imageUrl: FieldRef<"Memorial", 'String'>
    readonly createdAt: FieldRef<"Memorial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Memorial findUnique
   */
  export type MemorialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * Filter, which Memorial to fetch.
     */
    where: MemorialWhereUniqueInput
  }

  /**
   * Memorial findUniqueOrThrow
   */
  export type MemorialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * Filter, which Memorial to fetch.
     */
    where: MemorialWhereUniqueInput
  }

  /**
   * Memorial findFirst
   */
  export type MemorialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * Filter, which Memorial to fetch.
     */
    where?: MemorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memorials to fetch.
     */
    orderBy?: MemorialOrderByWithRelationInput | MemorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memorials.
     */
    cursor?: MemorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memorials.
     */
    distinct?: MemorialScalarFieldEnum | MemorialScalarFieldEnum[]
  }

  /**
   * Memorial findFirstOrThrow
   */
  export type MemorialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * Filter, which Memorial to fetch.
     */
    where?: MemorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memorials to fetch.
     */
    orderBy?: MemorialOrderByWithRelationInput | MemorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memorials.
     */
    cursor?: MemorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memorials.
     */
    distinct?: MemorialScalarFieldEnum | MemorialScalarFieldEnum[]
  }

  /**
   * Memorial findMany
   */
  export type MemorialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * Filter, which Memorials to fetch.
     */
    where?: MemorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memorials to fetch.
     */
    orderBy?: MemorialOrderByWithRelationInput | MemorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memorials.
     */
    cursor?: MemorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memorials.
     */
    skip?: number
    distinct?: MemorialScalarFieldEnum | MemorialScalarFieldEnum[]
  }

  /**
   * Memorial create
   */
  export type MemorialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * The data needed to create a Memorial.
     */
    data: XOR<MemorialCreateInput, MemorialUncheckedCreateInput>
  }

  /**
   * Memorial createMany
   */
  export type MemorialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memorials.
     */
    data: MemorialCreateManyInput | MemorialCreateManyInput[]
  }

  /**
   * Memorial createManyAndReturn
   */
  export type MemorialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * The data used to create many Memorials.
     */
    data: MemorialCreateManyInput | MemorialCreateManyInput[]
  }

  /**
   * Memorial update
   */
  export type MemorialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * The data needed to update a Memorial.
     */
    data: XOR<MemorialUpdateInput, MemorialUncheckedUpdateInput>
    /**
     * Choose, which Memorial to update.
     */
    where: MemorialWhereUniqueInput
  }

  /**
   * Memorial updateMany
   */
  export type MemorialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memorials.
     */
    data: XOR<MemorialUpdateManyMutationInput, MemorialUncheckedUpdateManyInput>
    /**
     * Filter which Memorials to update
     */
    where?: MemorialWhereInput
    /**
     * Limit how many Memorials to update.
     */
    limit?: number
  }

  /**
   * Memorial updateManyAndReturn
   */
  export type MemorialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * The data used to update Memorials.
     */
    data: XOR<MemorialUpdateManyMutationInput, MemorialUncheckedUpdateManyInput>
    /**
     * Filter which Memorials to update
     */
    where?: MemorialWhereInput
    /**
     * Limit how many Memorials to update.
     */
    limit?: number
  }

  /**
   * Memorial upsert
   */
  export type MemorialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * The filter to search for the Memorial to update in case it exists.
     */
    where: MemorialWhereUniqueInput
    /**
     * In case the Memorial found by the `where` argument doesn't exist, create a new Memorial with this data.
     */
    create: XOR<MemorialCreateInput, MemorialUncheckedCreateInput>
    /**
     * In case the Memorial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemorialUpdateInput, MemorialUncheckedUpdateInput>
  }

  /**
   * Memorial delete
   */
  export type MemorialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
    /**
     * Filter which Memorial to delete.
     */
    where: MemorialWhereUniqueInput
  }

  /**
   * Memorial deleteMany
   */
  export type MemorialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memorials to delete
     */
    where?: MemorialWhereInput
    /**
     * Limit how many Memorials to delete.
     */
    limit?: number
  }

  /**
   * Memorial.ceremony
   */
  export type Memorial$ceremonyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    where?: CeremonyWhereInput
  }

  /**
   * Memorial.reception
   */
  export type Memorial$receptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    where?: ReceptionWhereInput
  }

  /**
   * Memorial.notes
   */
  export type Memorial$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    where?: MemoryNoteWhereInput
    orderBy?: MemoryNoteOrderByWithRelationInput | MemoryNoteOrderByWithRelationInput[]
    cursor?: MemoryNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemoryNoteScalarFieldEnum | MemoryNoteScalarFieldEnum[]
  }

  /**
   * Memorial.attendances
   */
  export type Memorial$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Memorial without action
   */
  export type MemorialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memorial
     */
    select?: MemorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Memorial
     */
    omit?: MemorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemorialInclude<ExtArgs> | null
  }


  /**
   * Model Ceremony
   */

  export type AggregateCeremony = {
    _count: CeremonyCountAggregateOutputType | null
    _avg: CeremonyAvgAggregateOutputType | null
    _sum: CeremonySumAggregateOutputType | null
    _min: CeremonyMinAggregateOutputType | null
    _max: CeremonyMaxAggregateOutputType | null
  }

  export type CeremonyAvgAggregateOutputType = {
    id: number | null
    memorialId: number | null
  }

  export type CeremonySumAggregateOutputType = {
    id: number | null
    memorialId: number | null
  }

  export type CeremonyMinAggregateOutputType = {
    id: number | null
    memorialId: number | null
    dateTime: Date | null
    venue: string | null
    address: string | null
    mapUrl: string | null
    livestream: string | null
  }

  export type CeremonyMaxAggregateOutputType = {
    id: number | null
    memorialId: number | null
    dateTime: Date | null
    venue: string | null
    address: string | null
    mapUrl: string | null
    livestream: string | null
  }

  export type CeremonyCountAggregateOutputType = {
    id: number
    memorialId: number
    dateTime: number
    venue: number
    address: number
    mapUrl: number
    livestream: number
    _all: number
  }


  export type CeremonyAvgAggregateInputType = {
    id?: true
    memorialId?: true
  }

  export type CeremonySumAggregateInputType = {
    id?: true
    memorialId?: true
  }

  export type CeremonyMinAggregateInputType = {
    id?: true
    memorialId?: true
    dateTime?: true
    venue?: true
    address?: true
    mapUrl?: true
    livestream?: true
  }

  export type CeremonyMaxAggregateInputType = {
    id?: true
    memorialId?: true
    dateTime?: true
    venue?: true
    address?: true
    mapUrl?: true
    livestream?: true
  }

  export type CeremonyCountAggregateInputType = {
    id?: true
    memorialId?: true
    dateTime?: true
    venue?: true
    address?: true
    mapUrl?: true
    livestream?: true
    _all?: true
  }

  export type CeremonyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ceremony to aggregate.
     */
    where?: CeremonyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ceremonies to fetch.
     */
    orderBy?: CeremonyOrderByWithRelationInput | CeremonyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CeremonyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ceremonies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ceremonies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ceremonies
    **/
    _count?: true | CeremonyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CeremonyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CeremonySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CeremonyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CeremonyMaxAggregateInputType
  }

  export type GetCeremonyAggregateType<T extends CeremonyAggregateArgs> = {
        [P in keyof T & keyof AggregateCeremony]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCeremony[P]>
      : GetScalarType<T[P], AggregateCeremony[P]>
  }




  export type CeremonyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CeremonyWhereInput
    orderBy?: CeremonyOrderByWithAggregationInput | CeremonyOrderByWithAggregationInput[]
    by: CeremonyScalarFieldEnum[] | CeremonyScalarFieldEnum
    having?: CeremonyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CeremonyCountAggregateInputType | true
    _avg?: CeremonyAvgAggregateInputType
    _sum?: CeremonySumAggregateInputType
    _min?: CeremonyMinAggregateInputType
    _max?: CeremonyMaxAggregateInputType
  }

  export type CeremonyGroupByOutputType = {
    id: number
    memorialId: number
    dateTime: Date
    venue: string
    address: string | null
    mapUrl: string | null
    livestream: string | null
    _count: CeremonyCountAggregateOutputType | null
    _avg: CeremonyAvgAggregateOutputType | null
    _sum: CeremonySumAggregateOutputType | null
    _min: CeremonyMinAggregateOutputType | null
    _max: CeremonyMaxAggregateOutputType | null
  }

  type GetCeremonyGroupByPayload<T extends CeremonyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CeremonyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CeremonyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CeremonyGroupByOutputType[P]>
            : GetScalarType<T[P], CeremonyGroupByOutputType[P]>
        }
      >
    >


  export type CeremonySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    livestream?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ceremony"]>

  export type CeremonySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    livestream?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ceremony"]>

  export type CeremonySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    livestream?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ceremony"]>

  export type CeremonySelectScalar = {
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    livestream?: boolean
  }

  export type CeremonyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memorialId" | "dateTime" | "venue" | "address" | "mapUrl" | "livestream", ExtArgs["result"]["ceremony"]>
  export type CeremonyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type CeremonyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type CeremonyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }

  export type $CeremonyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ceremony"
    objects: {
      Memorial: Prisma.$MemorialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      memorialId: number
      dateTime: Date
      venue: string
      address: string | null
      mapUrl: string | null
      livestream: string | null
    }, ExtArgs["result"]["ceremony"]>
    composites: {}
  }

  type CeremonyGetPayload<S extends boolean | null | undefined | CeremonyDefaultArgs> = $Result.GetResult<Prisma.$CeremonyPayload, S>

  type CeremonyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CeremonyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CeremonyCountAggregateInputType | true
    }

  export interface CeremonyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ceremony'], meta: { name: 'Ceremony' } }
    /**
     * Find zero or one Ceremony that matches the filter.
     * @param {CeremonyFindUniqueArgs} args - Arguments to find a Ceremony
     * @example
     * // Get one Ceremony
     * const ceremony = await prisma.ceremony.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CeremonyFindUniqueArgs>(args: SelectSubset<T, CeremonyFindUniqueArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ceremony that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CeremonyFindUniqueOrThrowArgs} args - Arguments to find a Ceremony
     * @example
     * // Get one Ceremony
     * const ceremony = await prisma.ceremony.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CeremonyFindUniqueOrThrowArgs>(args: SelectSubset<T, CeremonyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ceremony that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CeremonyFindFirstArgs} args - Arguments to find a Ceremony
     * @example
     * // Get one Ceremony
     * const ceremony = await prisma.ceremony.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CeremonyFindFirstArgs>(args?: SelectSubset<T, CeremonyFindFirstArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ceremony that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CeremonyFindFirstOrThrowArgs} args - Arguments to find a Ceremony
     * @example
     * // Get one Ceremony
     * const ceremony = await prisma.ceremony.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CeremonyFindFirstOrThrowArgs>(args?: SelectSubset<T, CeremonyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ceremonies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CeremonyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ceremonies
     * const ceremonies = await prisma.ceremony.findMany()
     * 
     * // Get first 10 Ceremonies
     * const ceremonies = await prisma.ceremony.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ceremonyWithIdOnly = await prisma.ceremony.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CeremonyFindManyArgs>(args?: SelectSubset<T, CeremonyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ceremony.
     * @param {CeremonyCreateArgs} args - Arguments to create a Ceremony.
     * @example
     * // Create one Ceremony
     * const Ceremony = await prisma.ceremony.create({
     *   data: {
     *     // ... data to create a Ceremony
     *   }
     * })
     * 
     */
    create<T extends CeremonyCreateArgs>(args: SelectSubset<T, CeremonyCreateArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ceremonies.
     * @param {CeremonyCreateManyArgs} args - Arguments to create many Ceremonies.
     * @example
     * // Create many Ceremonies
     * const ceremony = await prisma.ceremony.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CeremonyCreateManyArgs>(args?: SelectSubset<T, CeremonyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ceremonies and returns the data saved in the database.
     * @param {CeremonyCreateManyAndReturnArgs} args - Arguments to create many Ceremonies.
     * @example
     * // Create many Ceremonies
     * const ceremony = await prisma.ceremony.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ceremonies and only return the `id`
     * const ceremonyWithIdOnly = await prisma.ceremony.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CeremonyCreateManyAndReturnArgs>(args?: SelectSubset<T, CeremonyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ceremony.
     * @param {CeremonyDeleteArgs} args - Arguments to delete one Ceremony.
     * @example
     * // Delete one Ceremony
     * const Ceremony = await prisma.ceremony.delete({
     *   where: {
     *     // ... filter to delete one Ceremony
     *   }
     * })
     * 
     */
    delete<T extends CeremonyDeleteArgs>(args: SelectSubset<T, CeremonyDeleteArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ceremony.
     * @param {CeremonyUpdateArgs} args - Arguments to update one Ceremony.
     * @example
     * // Update one Ceremony
     * const ceremony = await prisma.ceremony.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CeremonyUpdateArgs>(args: SelectSubset<T, CeremonyUpdateArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ceremonies.
     * @param {CeremonyDeleteManyArgs} args - Arguments to filter Ceremonies to delete.
     * @example
     * // Delete a few Ceremonies
     * const { count } = await prisma.ceremony.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CeremonyDeleteManyArgs>(args?: SelectSubset<T, CeremonyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ceremonies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CeremonyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ceremonies
     * const ceremony = await prisma.ceremony.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CeremonyUpdateManyArgs>(args: SelectSubset<T, CeremonyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ceremonies and returns the data updated in the database.
     * @param {CeremonyUpdateManyAndReturnArgs} args - Arguments to update many Ceremonies.
     * @example
     * // Update many Ceremonies
     * const ceremony = await prisma.ceremony.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ceremonies and only return the `id`
     * const ceremonyWithIdOnly = await prisma.ceremony.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CeremonyUpdateManyAndReturnArgs>(args: SelectSubset<T, CeremonyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ceremony.
     * @param {CeremonyUpsertArgs} args - Arguments to update or create a Ceremony.
     * @example
     * // Update or create a Ceremony
     * const ceremony = await prisma.ceremony.upsert({
     *   create: {
     *     // ... data to create a Ceremony
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ceremony we want to update
     *   }
     * })
     */
    upsert<T extends CeremonyUpsertArgs>(args: SelectSubset<T, CeremonyUpsertArgs<ExtArgs>>): Prisma__CeremonyClient<$Result.GetResult<Prisma.$CeremonyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ceremonies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CeremonyCountArgs} args - Arguments to filter Ceremonies to count.
     * @example
     * // Count the number of Ceremonies
     * const count = await prisma.ceremony.count({
     *   where: {
     *     // ... the filter for the Ceremonies we want to count
     *   }
     * })
    **/
    count<T extends CeremonyCountArgs>(
      args?: Subset<T, CeremonyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CeremonyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ceremony.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CeremonyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CeremonyAggregateArgs>(args: Subset<T, CeremonyAggregateArgs>): Prisma.PrismaPromise<GetCeremonyAggregateType<T>>

    /**
     * Group by Ceremony.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CeremonyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CeremonyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CeremonyGroupByArgs['orderBy'] }
        : { orderBy?: CeremonyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CeremonyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCeremonyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ceremony model
   */
  readonly fields: CeremonyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ceremony.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CeremonyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Memorial<T extends MemorialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemorialDefaultArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ceremony model
   */
  interface CeremonyFieldRefs {
    readonly id: FieldRef<"Ceremony", 'Int'>
    readonly memorialId: FieldRef<"Ceremony", 'Int'>
    readonly dateTime: FieldRef<"Ceremony", 'DateTime'>
    readonly venue: FieldRef<"Ceremony", 'String'>
    readonly address: FieldRef<"Ceremony", 'String'>
    readonly mapUrl: FieldRef<"Ceremony", 'String'>
    readonly livestream: FieldRef<"Ceremony", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ceremony findUnique
   */
  export type CeremonyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * Filter, which Ceremony to fetch.
     */
    where: CeremonyWhereUniqueInput
  }

  /**
   * Ceremony findUniqueOrThrow
   */
  export type CeremonyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * Filter, which Ceremony to fetch.
     */
    where: CeremonyWhereUniqueInput
  }

  /**
   * Ceremony findFirst
   */
  export type CeremonyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * Filter, which Ceremony to fetch.
     */
    where?: CeremonyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ceremonies to fetch.
     */
    orderBy?: CeremonyOrderByWithRelationInput | CeremonyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ceremonies.
     */
    cursor?: CeremonyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ceremonies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ceremonies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ceremonies.
     */
    distinct?: CeremonyScalarFieldEnum | CeremonyScalarFieldEnum[]
  }

  /**
   * Ceremony findFirstOrThrow
   */
  export type CeremonyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * Filter, which Ceremony to fetch.
     */
    where?: CeremonyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ceremonies to fetch.
     */
    orderBy?: CeremonyOrderByWithRelationInput | CeremonyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ceremonies.
     */
    cursor?: CeremonyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ceremonies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ceremonies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ceremonies.
     */
    distinct?: CeremonyScalarFieldEnum | CeremonyScalarFieldEnum[]
  }

  /**
   * Ceremony findMany
   */
  export type CeremonyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * Filter, which Ceremonies to fetch.
     */
    where?: CeremonyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ceremonies to fetch.
     */
    orderBy?: CeremonyOrderByWithRelationInput | CeremonyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ceremonies.
     */
    cursor?: CeremonyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ceremonies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ceremonies.
     */
    skip?: number
    distinct?: CeremonyScalarFieldEnum | CeremonyScalarFieldEnum[]
  }

  /**
   * Ceremony create
   */
  export type CeremonyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * The data needed to create a Ceremony.
     */
    data: XOR<CeremonyCreateInput, CeremonyUncheckedCreateInput>
  }

  /**
   * Ceremony createMany
   */
  export type CeremonyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ceremonies.
     */
    data: CeremonyCreateManyInput | CeremonyCreateManyInput[]
  }

  /**
   * Ceremony createManyAndReturn
   */
  export type CeremonyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * The data used to create many Ceremonies.
     */
    data: CeremonyCreateManyInput | CeremonyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ceremony update
   */
  export type CeremonyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * The data needed to update a Ceremony.
     */
    data: XOR<CeremonyUpdateInput, CeremonyUncheckedUpdateInput>
    /**
     * Choose, which Ceremony to update.
     */
    where: CeremonyWhereUniqueInput
  }

  /**
   * Ceremony updateMany
   */
  export type CeremonyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ceremonies.
     */
    data: XOR<CeremonyUpdateManyMutationInput, CeremonyUncheckedUpdateManyInput>
    /**
     * Filter which Ceremonies to update
     */
    where?: CeremonyWhereInput
    /**
     * Limit how many Ceremonies to update.
     */
    limit?: number
  }

  /**
   * Ceremony updateManyAndReturn
   */
  export type CeremonyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * The data used to update Ceremonies.
     */
    data: XOR<CeremonyUpdateManyMutationInput, CeremonyUncheckedUpdateManyInput>
    /**
     * Filter which Ceremonies to update
     */
    where?: CeremonyWhereInput
    /**
     * Limit how many Ceremonies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ceremony upsert
   */
  export type CeremonyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * The filter to search for the Ceremony to update in case it exists.
     */
    where: CeremonyWhereUniqueInput
    /**
     * In case the Ceremony found by the `where` argument doesn't exist, create a new Ceremony with this data.
     */
    create: XOR<CeremonyCreateInput, CeremonyUncheckedCreateInput>
    /**
     * In case the Ceremony was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CeremonyUpdateInput, CeremonyUncheckedUpdateInput>
  }

  /**
   * Ceremony delete
   */
  export type CeremonyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
    /**
     * Filter which Ceremony to delete.
     */
    where: CeremonyWhereUniqueInput
  }

  /**
   * Ceremony deleteMany
   */
  export type CeremonyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ceremonies to delete
     */
    where?: CeremonyWhereInput
    /**
     * Limit how many Ceremonies to delete.
     */
    limit?: number
  }

  /**
   * Ceremony without action
   */
  export type CeremonyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ceremony
     */
    select?: CeremonySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ceremony
     */
    omit?: CeremonyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CeremonyInclude<ExtArgs> | null
  }


  /**
   * Model Reception
   */

  export type AggregateReception = {
    _count: ReceptionCountAggregateOutputType | null
    _avg: ReceptionAvgAggregateOutputType | null
    _sum: ReceptionSumAggregateOutputType | null
    _min: ReceptionMinAggregateOutputType | null
    _max: ReceptionMaxAggregateOutputType | null
  }

  export type ReceptionAvgAggregateOutputType = {
    id: number | null
    memorialId: number | null
  }

  export type ReceptionSumAggregateOutputType = {
    id: number | null
    memorialId: number | null
  }

  export type ReceptionMinAggregateOutputType = {
    id: number | null
    memorialId: number | null
    dateTime: Date | null
    venue: string | null
    address: string | null
    mapUrl: string | null
    welcomeScope: $Enums.WelcomeScope | null
    wishes: string | null
  }

  export type ReceptionMaxAggregateOutputType = {
    id: number | null
    memorialId: number | null
    dateTime: Date | null
    venue: string | null
    address: string | null
    mapUrl: string | null
    welcomeScope: $Enums.WelcomeScope | null
    wishes: string | null
  }

  export type ReceptionCountAggregateOutputType = {
    id: number
    memorialId: number
    dateTime: number
    venue: number
    address: number
    mapUrl: number
    welcomeScope: number
    wishes: number
    _all: number
  }


  export type ReceptionAvgAggregateInputType = {
    id?: true
    memorialId?: true
  }

  export type ReceptionSumAggregateInputType = {
    id?: true
    memorialId?: true
  }

  export type ReceptionMinAggregateInputType = {
    id?: true
    memorialId?: true
    dateTime?: true
    venue?: true
    address?: true
    mapUrl?: true
    welcomeScope?: true
    wishes?: true
  }

  export type ReceptionMaxAggregateInputType = {
    id?: true
    memorialId?: true
    dateTime?: true
    venue?: true
    address?: true
    mapUrl?: true
    welcomeScope?: true
    wishes?: true
  }

  export type ReceptionCountAggregateInputType = {
    id?: true
    memorialId?: true
    dateTime?: true
    venue?: true
    address?: true
    mapUrl?: true
    welcomeScope?: true
    wishes?: true
    _all?: true
  }

  export type ReceptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reception to aggregate.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receptions
    **/
    _count?: true | ReceptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceptionMaxAggregateInputType
  }

  export type GetReceptionAggregateType<T extends ReceptionAggregateArgs> = {
        [P in keyof T & keyof AggregateReception]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReception[P]>
      : GetScalarType<T[P], AggregateReception[P]>
  }




  export type ReceptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionWhereInput
    orderBy?: ReceptionOrderByWithAggregationInput | ReceptionOrderByWithAggregationInput[]
    by: ReceptionScalarFieldEnum[] | ReceptionScalarFieldEnum
    having?: ReceptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceptionCountAggregateInputType | true
    _avg?: ReceptionAvgAggregateInputType
    _sum?: ReceptionSumAggregateInputType
    _min?: ReceptionMinAggregateInputType
    _max?: ReceptionMaxAggregateInputType
  }

  export type ReceptionGroupByOutputType = {
    id: number
    memorialId: number
    dateTime: Date
    venue: string
    address: string | null
    mapUrl: string | null
    welcomeScope: $Enums.WelcomeScope
    wishes: string | null
    _count: ReceptionCountAggregateOutputType | null
    _avg: ReceptionAvgAggregateOutputType | null
    _sum: ReceptionSumAggregateOutputType | null
    _min: ReceptionMinAggregateOutputType | null
    _max: ReceptionMaxAggregateOutputType | null
  }

  type GetReceptionGroupByPayload<T extends ReceptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceptionGroupByOutputType[P]>
            : GetScalarType<T[P], ReceptionGroupByOutputType[P]>
        }
      >
    >


  export type ReceptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    welcomeScope?: boolean
    wishes?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reception"]>

  export type ReceptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    welcomeScope?: boolean
    wishes?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reception"]>

  export type ReceptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    welcomeScope?: boolean
    wishes?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reception"]>

  export type ReceptionSelectScalar = {
    id?: boolean
    memorialId?: boolean
    dateTime?: boolean
    venue?: boolean
    address?: boolean
    mapUrl?: boolean
    welcomeScope?: boolean
    wishes?: boolean
  }

  export type ReceptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memorialId" | "dateTime" | "venue" | "address" | "mapUrl" | "welcomeScope" | "wishes", ExtArgs["result"]["reception"]>
  export type ReceptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type ReceptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type ReceptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }

  export type $ReceptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reception"
    objects: {
      Memorial: Prisma.$MemorialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      memorialId: number
      dateTime: Date
      venue: string
      address: string | null
      mapUrl: string | null
      welcomeScope: $Enums.WelcomeScope
      wishes: string | null
    }, ExtArgs["result"]["reception"]>
    composites: {}
  }

  type ReceptionGetPayload<S extends boolean | null | undefined | ReceptionDefaultArgs> = $Result.GetResult<Prisma.$ReceptionPayload, S>

  type ReceptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceptionCountAggregateInputType | true
    }

  export interface ReceptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reception'], meta: { name: 'Reception' } }
    /**
     * Find zero or one Reception that matches the filter.
     * @param {ReceptionFindUniqueArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceptionFindUniqueArgs>(args: SelectSubset<T, ReceptionFindUniqueArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reception that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceptionFindUniqueOrThrowArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reception that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionFindFirstArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceptionFindFirstArgs>(args?: SelectSubset<T, ReceptionFindFirstArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reception that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionFindFirstOrThrowArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receptions
     * const receptions = await prisma.reception.findMany()
     * 
     * // Get first 10 Receptions
     * const receptions = await prisma.reception.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receptionWithIdOnly = await prisma.reception.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceptionFindManyArgs>(args?: SelectSubset<T, ReceptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reception.
     * @param {ReceptionCreateArgs} args - Arguments to create a Reception.
     * @example
     * // Create one Reception
     * const Reception = await prisma.reception.create({
     *   data: {
     *     // ... data to create a Reception
     *   }
     * })
     * 
     */
    create<T extends ReceptionCreateArgs>(args: SelectSubset<T, ReceptionCreateArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receptions.
     * @param {ReceptionCreateManyArgs} args - Arguments to create many Receptions.
     * @example
     * // Create many Receptions
     * const reception = await prisma.reception.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceptionCreateManyArgs>(args?: SelectSubset<T, ReceptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receptions and returns the data saved in the database.
     * @param {ReceptionCreateManyAndReturnArgs} args - Arguments to create many Receptions.
     * @example
     * // Create many Receptions
     * const reception = await prisma.reception.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receptions and only return the `id`
     * const receptionWithIdOnly = await prisma.reception.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reception.
     * @param {ReceptionDeleteArgs} args - Arguments to delete one Reception.
     * @example
     * // Delete one Reception
     * const Reception = await prisma.reception.delete({
     *   where: {
     *     // ... filter to delete one Reception
     *   }
     * })
     * 
     */
    delete<T extends ReceptionDeleteArgs>(args: SelectSubset<T, ReceptionDeleteArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reception.
     * @param {ReceptionUpdateArgs} args - Arguments to update one Reception.
     * @example
     * // Update one Reception
     * const reception = await prisma.reception.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceptionUpdateArgs>(args: SelectSubset<T, ReceptionUpdateArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receptions.
     * @param {ReceptionDeleteManyArgs} args - Arguments to filter Receptions to delete.
     * @example
     * // Delete a few Receptions
     * const { count } = await prisma.reception.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceptionDeleteManyArgs>(args?: SelectSubset<T, ReceptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receptions
     * const reception = await prisma.reception.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceptionUpdateManyArgs>(args: SelectSubset<T, ReceptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receptions and returns the data updated in the database.
     * @param {ReceptionUpdateManyAndReturnArgs} args - Arguments to update many Receptions.
     * @example
     * // Update many Receptions
     * const reception = await prisma.reception.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Receptions and only return the `id`
     * const receptionWithIdOnly = await prisma.reception.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reception.
     * @param {ReceptionUpsertArgs} args - Arguments to update or create a Reception.
     * @example
     * // Update or create a Reception
     * const reception = await prisma.reception.upsert({
     *   create: {
     *     // ... data to create a Reception
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reception we want to update
     *   }
     * })
     */
    upsert<T extends ReceptionUpsertArgs>(args: SelectSubset<T, ReceptionUpsertArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionCountArgs} args - Arguments to filter Receptions to count.
     * @example
     * // Count the number of Receptions
     * const count = await prisma.reception.count({
     *   where: {
     *     // ... the filter for the Receptions we want to count
     *   }
     * })
    **/
    count<T extends ReceptionCountArgs>(
      args?: Subset<T, ReceptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reception.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceptionAggregateArgs>(args: Subset<T, ReceptionAggregateArgs>): Prisma.PrismaPromise<GetReceptionAggregateType<T>>

    /**
     * Group by Reception.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceptionGroupByArgs['orderBy'] }
        : { orderBy?: ReceptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reception model
   */
  readonly fields: ReceptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reception.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Memorial<T extends MemorialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemorialDefaultArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reception model
   */
  interface ReceptionFieldRefs {
    readonly id: FieldRef<"Reception", 'Int'>
    readonly memorialId: FieldRef<"Reception", 'Int'>
    readonly dateTime: FieldRef<"Reception", 'DateTime'>
    readonly venue: FieldRef<"Reception", 'String'>
    readonly address: FieldRef<"Reception", 'String'>
    readonly mapUrl: FieldRef<"Reception", 'String'>
    readonly welcomeScope: FieldRef<"Reception", 'WelcomeScope'>
    readonly wishes: FieldRef<"Reception", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Reception findUnique
   */
  export type ReceptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception findUniqueOrThrow
   */
  export type ReceptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception findFirst
   */
  export type ReceptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receptions.
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receptions.
     */
    distinct?: ReceptionScalarFieldEnum | ReceptionScalarFieldEnum[]
  }

  /**
   * Reception findFirstOrThrow
   */
  export type ReceptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receptions.
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receptions.
     */
    distinct?: ReceptionScalarFieldEnum | ReceptionScalarFieldEnum[]
  }

  /**
   * Reception findMany
   */
  export type ReceptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Receptions to fetch.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receptions.
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    distinct?: ReceptionScalarFieldEnum | ReceptionScalarFieldEnum[]
  }

  /**
   * Reception create
   */
  export type ReceptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reception.
     */
    data: XOR<ReceptionCreateInput, ReceptionUncheckedCreateInput>
  }

  /**
   * Reception createMany
   */
  export type ReceptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receptions.
     */
    data: ReceptionCreateManyInput | ReceptionCreateManyInput[]
  }

  /**
   * Reception createManyAndReturn
   */
  export type ReceptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * The data used to create many Receptions.
     */
    data: ReceptionCreateManyInput | ReceptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reception update
   */
  export type ReceptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reception.
     */
    data: XOR<ReceptionUpdateInput, ReceptionUncheckedUpdateInput>
    /**
     * Choose, which Reception to update.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception updateMany
   */
  export type ReceptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receptions.
     */
    data: XOR<ReceptionUpdateManyMutationInput, ReceptionUncheckedUpdateManyInput>
    /**
     * Filter which Receptions to update
     */
    where?: ReceptionWhereInput
    /**
     * Limit how many Receptions to update.
     */
    limit?: number
  }

  /**
   * Reception updateManyAndReturn
   */
  export type ReceptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * The data used to update Receptions.
     */
    data: XOR<ReceptionUpdateManyMutationInput, ReceptionUncheckedUpdateManyInput>
    /**
     * Filter which Receptions to update
     */
    where?: ReceptionWhereInput
    /**
     * Limit how many Receptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reception upsert
   */
  export type ReceptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reception to update in case it exists.
     */
    where: ReceptionWhereUniqueInput
    /**
     * In case the Reception found by the `where` argument doesn't exist, create a new Reception with this data.
     */
    create: XOR<ReceptionCreateInput, ReceptionUncheckedCreateInput>
    /**
     * In case the Reception was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceptionUpdateInput, ReceptionUncheckedUpdateInput>
  }

  /**
   * Reception delete
   */
  export type ReceptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter which Reception to delete.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception deleteMany
   */
  export type ReceptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receptions to delete
     */
    where?: ReceptionWhereInput
    /**
     * Limit how many Receptions to delete.
     */
    limit?: number
  }

  /**
   * Reception without action
   */
  export type ReceptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reception
     */
    omit?: ReceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
    memorialId: number | null
    count: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
    memorialId: number | null
    count: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: number | null
    memorialId: number | null
    name: string | null
    email: string | null
    count: number | null
    notes: string | null
    wantsToSpeak: boolean | null
    relationsJson: string | null
    createdAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: number | null
    memorialId: number | null
    name: string | null
    email: string | null
    count: number | null
    notes: string | null
    wantsToSpeak: boolean | null
    relationsJson: string | null
    createdAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    memorialId: number
    name: number
    email: number
    count: number
    notes: number
    wantsToSpeak: number
    relationsJson: number
    createdAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
    memorialId?: true
    count?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
    memorialId?: true
    count?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    memorialId?: true
    name?: true
    email?: true
    count?: true
    notes?: true
    wantsToSpeak?: true
    relationsJson?: true
    createdAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    memorialId?: true
    name?: true
    email?: true
    count?: true
    notes?: true
    wantsToSpeak?: true
    relationsJson?: true
    createdAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    memorialId?: true
    name?: true
    email?: true
    count?: true
    notes?: true
    wantsToSpeak?: true
    relationsJson?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: number
    memorialId: number
    name: string
    email: string
    count: number
    notes: string | null
    wantsToSpeak: boolean
    relationsJson: string | null
    createdAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    name?: boolean
    email?: boolean
    count?: boolean
    notes?: boolean
    wantsToSpeak?: boolean
    relationsJson?: boolean
    createdAt?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    name?: boolean
    email?: boolean
    count?: boolean
    notes?: boolean
    wantsToSpeak?: boolean
    relationsJson?: boolean
    createdAt?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    name?: boolean
    email?: boolean
    count?: boolean
    notes?: boolean
    wantsToSpeak?: boolean
    relationsJson?: boolean
    createdAt?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    memorialId?: boolean
    name?: boolean
    email?: boolean
    count?: boolean
    notes?: boolean
    wantsToSpeak?: boolean
    relationsJson?: boolean
    createdAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memorialId" | "name" | "email" | "count" | "notes" | "wantsToSpeak" | "relationsJson" | "createdAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      Memorial: Prisma.$MemorialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      memorialId: number
      name: string
      email: string
      count: number
      notes: string | null
      wantsToSpeak: boolean
      relationsJson: string | null
      createdAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Memorial<T extends MemorialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemorialDefaultArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'Int'>
    readonly memorialId: FieldRef<"Attendance", 'Int'>
    readonly name: FieldRef<"Attendance", 'String'>
    readonly email: FieldRef<"Attendance", 'String'>
    readonly count: FieldRef<"Attendance", 'Int'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly wantsToSpeak: FieldRef<"Attendance", 'Boolean'>
    readonly relationsJson: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model MemoryNote
   */

  export type AggregateMemoryNote = {
    _count: MemoryNoteCountAggregateOutputType | null
    _avg: MemoryNoteAvgAggregateOutputType | null
    _sum: MemoryNoteSumAggregateOutputType | null
    _min: MemoryNoteMinAggregateOutputType | null
    _max: MemoryNoteMaxAggregateOutputType | null
  }

  export type MemoryNoteAvgAggregateOutputType = {
    id: number | null
    memorialId: number | null
  }

  export type MemoryNoteSumAggregateOutputType = {
    id: number | null
    memorialId: number | null
  }

  export type MemoryNoteMinAggregateOutputType = {
    id: number | null
    memorialId: number | null
    author: string | null
    text: string | null
    approved: boolean | null
    createdAt: Date | null
  }

  export type MemoryNoteMaxAggregateOutputType = {
    id: number | null
    memorialId: number | null
    author: string | null
    text: string | null
    approved: boolean | null
    createdAt: Date | null
  }

  export type MemoryNoteCountAggregateOutputType = {
    id: number
    memorialId: number
    author: number
    text: number
    approved: number
    createdAt: number
    _all: number
  }


  export type MemoryNoteAvgAggregateInputType = {
    id?: true
    memorialId?: true
  }

  export type MemoryNoteSumAggregateInputType = {
    id?: true
    memorialId?: true
  }

  export type MemoryNoteMinAggregateInputType = {
    id?: true
    memorialId?: true
    author?: true
    text?: true
    approved?: true
    createdAt?: true
  }

  export type MemoryNoteMaxAggregateInputType = {
    id?: true
    memorialId?: true
    author?: true
    text?: true
    approved?: true
    createdAt?: true
  }

  export type MemoryNoteCountAggregateInputType = {
    id?: true
    memorialId?: true
    author?: true
    text?: true
    approved?: true
    createdAt?: true
    _all?: true
  }

  export type MemoryNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemoryNote to aggregate.
     */
    where?: MemoryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemoryNotes to fetch.
     */
    orderBy?: MemoryNoteOrderByWithRelationInput | MemoryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemoryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemoryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemoryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemoryNotes
    **/
    _count?: true | MemoryNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemoryNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemoryNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemoryNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemoryNoteMaxAggregateInputType
  }

  export type GetMemoryNoteAggregateType<T extends MemoryNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateMemoryNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemoryNote[P]>
      : GetScalarType<T[P], AggregateMemoryNote[P]>
  }




  export type MemoryNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryNoteWhereInput
    orderBy?: MemoryNoteOrderByWithAggregationInput | MemoryNoteOrderByWithAggregationInput[]
    by: MemoryNoteScalarFieldEnum[] | MemoryNoteScalarFieldEnum
    having?: MemoryNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemoryNoteCountAggregateInputType | true
    _avg?: MemoryNoteAvgAggregateInputType
    _sum?: MemoryNoteSumAggregateInputType
    _min?: MemoryNoteMinAggregateInputType
    _max?: MemoryNoteMaxAggregateInputType
  }

  export type MemoryNoteGroupByOutputType = {
    id: number
    memorialId: number
    author: string
    text: string
    approved: boolean
    createdAt: Date
    _count: MemoryNoteCountAggregateOutputType | null
    _avg: MemoryNoteAvgAggregateOutputType | null
    _sum: MemoryNoteSumAggregateOutputType | null
    _min: MemoryNoteMinAggregateOutputType | null
    _max: MemoryNoteMaxAggregateOutputType | null
  }

  type GetMemoryNoteGroupByPayload<T extends MemoryNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemoryNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemoryNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemoryNoteGroupByOutputType[P]>
            : GetScalarType<T[P], MemoryNoteGroupByOutputType[P]>
        }
      >
    >


  export type MemoryNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    author?: boolean
    text?: boolean
    approved?: boolean
    createdAt?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memoryNote"]>

  export type MemoryNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    author?: boolean
    text?: boolean
    approved?: boolean
    createdAt?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memoryNote"]>

  export type MemoryNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memorialId?: boolean
    author?: boolean
    text?: boolean
    approved?: boolean
    createdAt?: boolean
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memoryNote"]>

  export type MemoryNoteSelectScalar = {
    id?: boolean
    memorialId?: boolean
    author?: boolean
    text?: boolean
    approved?: boolean
    createdAt?: boolean
  }

  export type MemoryNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memorialId" | "author" | "text" | "approved" | "createdAt", ExtArgs["result"]["memoryNote"]>
  export type MemoryNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type MemoryNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }
  export type MemoryNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Memorial?: boolean | MemorialDefaultArgs<ExtArgs>
  }

  export type $MemoryNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemoryNote"
    objects: {
      Memorial: Prisma.$MemorialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      memorialId: number
      author: string
      text: string
      approved: boolean
      createdAt: Date
    }, ExtArgs["result"]["memoryNote"]>
    composites: {}
  }

  type MemoryNoteGetPayload<S extends boolean | null | undefined | MemoryNoteDefaultArgs> = $Result.GetResult<Prisma.$MemoryNotePayload, S>

  type MemoryNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemoryNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemoryNoteCountAggregateInputType | true
    }

  export interface MemoryNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemoryNote'], meta: { name: 'MemoryNote' } }
    /**
     * Find zero or one MemoryNote that matches the filter.
     * @param {MemoryNoteFindUniqueArgs} args - Arguments to find a MemoryNote
     * @example
     * // Get one MemoryNote
     * const memoryNote = await prisma.memoryNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemoryNoteFindUniqueArgs>(args: SelectSubset<T, MemoryNoteFindUniqueArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemoryNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemoryNoteFindUniqueOrThrowArgs} args - Arguments to find a MemoryNote
     * @example
     * // Get one MemoryNote
     * const memoryNote = await prisma.memoryNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemoryNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, MemoryNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemoryNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryNoteFindFirstArgs} args - Arguments to find a MemoryNote
     * @example
     * // Get one MemoryNote
     * const memoryNote = await prisma.memoryNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemoryNoteFindFirstArgs>(args?: SelectSubset<T, MemoryNoteFindFirstArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemoryNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryNoteFindFirstOrThrowArgs} args - Arguments to find a MemoryNote
     * @example
     * // Get one MemoryNote
     * const memoryNote = await prisma.memoryNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemoryNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, MemoryNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemoryNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemoryNotes
     * const memoryNotes = await prisma.memoryNote.findMany()
     * 
     * // Get first 10 MemoryNotes
     * const memoryNotes = await prisma.memoryNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memoryNoteWithIdOnly = await prisma.memoryNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemoryNoteFindManyArgs>(args?: SelectSubset<T, MemoryNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemoryNote.
     * @param {MemoryNoteCreateArgs} args - Arguments to create a MemoryNote.
     * @example
     * // Create one MemoryNote
     * const MemoryNote = await prisma.memoryNote.create({
     *   data: {
     *     // ... data to create a MemoryNote
     *   }
     * })
     * 
     */
    create<T extends MemoryNoteCreateArgs>(args: SelectSubset<T, MemoryNoteCreateArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemoryNotes.
     * @param {MemoryNoteCreateManyArgs} args - Arguments to create many MemoryNotes.
     * @example
     * // Create many MemoryNotes
     * const memoryNote = await prisma.memoryNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemoryNoteCreateManyArgs>(args?: SelectSubset<T, MemoryNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemoryNotes and returns the data saved in the database.
     * @param {MemoryNoteCreateManyAndReturnArgs} args - Arguments to create many MemoryNotes.
     * @example
     * // Create many MemoryNotes
     * const memoryNote = await prisma.memoryNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemoryNotes and only return the `id`
     * const memoryNoteWithIdOnly = await prisma.memoryNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemoryNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, MemoryNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemoryNote.
     * @param {MemoryNoteDeleteArgs} args - Arguments to delete one MemoryNote.
     * @example
     * // Delete one MemoryNote
     * const MemoryNote = await prisma.memoryNote.delete({
     *   where: {
     *     // ... filter to delete one MemoryNote
     *   }
     * })
     * 
     */
    delete<T extends MemoryNoteDeleteArgs>(args: SelectSubset<T, MemoryNoteDeleteArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemoryNote.
     * @param {MemoryNoteUpdateArgs} args - Arguments to update one MemoryNote.
     * @example
     * // Update one MemoryNote
     * const memoryNote = await prisma.memoryNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemoryNoteUpdateArgs>(args: SelectSubset<T, MemoryNoteUpdateArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemoryNotes.
     * @param {MemoryNoteDeleteManyArgs} args - Arguments to filter MemoryNotes to delete.
     * @example
     * // Delete a few MemoryNotes
     * const { count } = await prisma.memoryNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemoryNoteDeleteManyArgs>(args?: SelectSubset<T, MemoryNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemoryNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemoryNotes
     * const memoryNote = await prisma.memoryNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemoryNoteUpdateManyArgs>(args: SelectSubset<T, MemoryNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemoryNotes and returns the data updated in the database.
     * @param {MemoryNoteUpdateManyAndReturnArgs} args - Arguments to update many MemoryNotes.
     * @example
     * // Update many MemoryNotes
     * const memoryNote = await prisma.memoryNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemoryNotes and only return the `id`
     * const memoryNoteWithIdOnly = await prisma.memoryNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemoryNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, MemoryNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemoryNote.
     * @param {MemoryNoteUpsertArgs} args - Arguments to update or create a MemoryNote.
     * @example
     * // Update or create a MemoryNote
     * const memoryNote = await prisma.memoryNote.upsert({
     *   create: {
     *     // ... data to create a MemoryNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemoryNote we want to update
     *   }
     * })
     */
    upsert<T extends MemoryNoteUpsertArgs>(args: SelectSubset<T, MemoryNoteUpsertArgs<ExtArgs>>): Prisma__MemoryNoteClient<$Result.GetResult<Prisma.$MemoryNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemoryNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryNoteCountArgs} args - Arguments to filter MemoryNotes to count.
     * @example
     * // Count the number of MemoryNotes
     * const count = await prisma.memoryNote.count({
     *   where: {
     *     // ... the filter for the MemoryNotes we want to count
     *   }
     * })
    **/
    count<T extends MemoryNoteCountArgs>(
      args?: Subset<T, MemoryNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemoryNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemoryNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemoryNoteAggregateArgs>(args: Subset<T, MemoryNoteAggregateArgs>): Prisma.PrismaPromise<GetMemoryNoteAggregateType<T>>

    /**
     * Group by MemoryNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemoryNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemoryNoteGroupByArgs['orderBy'] }
        : { orderBy?: MemoryNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemoryNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemoryNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemoryNote model
   */
  readonly fields: MemoryNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemoryNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemoryNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Memorial<T extends MemorialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemorialDefaultArgs<ExtArgs>>): Prisma__MemorialClient<$Result.GetResult<Prisma.$MemorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemoryNote model
   */
  interface MemoryNoteFieldRefs {
    readonly id: FieldRef<"MemoryNote", 'Int'>
    readonly memorialId: FieldRef<"MemoryNote", 'Int'>
    readonly author: FieldRef<"MemoryNote", 'String'>
    readonly text: FieldRef<"MemoryNote", 'String'>
    readonly approved: FieldRef<"MemoryNote", 'Boolean'>
    readonly createdAt: FieldRef<"MemoryNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemoryNote findUnique
   */
  export type MemoryNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * Filter, which MemoryNote to fetch.
     */
    where: MemoryNoteWhereUniqueInput
  }

  /**
   * MemoryNote findUniqueOrThrow
   */
  export type MemoryNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * Filter, which MemoryNote to fetch.
     */
    where: MemoryNoteWhereUniqueInput
  }

  /**
   * MemoryNote findFirst
   */
  export type MemoryNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * Filter, which MemoryNote to fetch.
     */
    where?: MemoryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemoryNotes to fetch.
     */
    orderBy?: MemoryNoteOrderByWithRelationInput | MemoryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemoryNotes.
     */
    cursor?: MemoryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemoryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemoryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemoryNotes.
     */
    distinct?: MemoryNoteScalarFieldEnum | MemoryNoteScalarFieldEnum[]
  }

  /**
   * MemoryNote findFirstOrThrow
   */
  export type MemoryNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * Filter, which MemoryNote to fetch.
     */
    where?: MemoryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemoryNotes to fetch.
     */
    orderBy?: MemoryNoteOrderByWithRelationInput | MemoryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemoryNotes.
     */
    cursor?: MemoryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemoryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemoryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemoryNotes.
     */
    distinct?: MemoryNoteScalarFieldEnum | MemoryNoteScalarFieldEnum[]
  }

  /**
   * MemoryNote findMany
   */
  export type MemoryNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * Filter, which MemoryNotes to fetch.
     */
    where?: MemoryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemoryNotes to fetch.
     */
    orderBy?: MemoryNoteOrderByWithRelationInput | MemoryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemoryNotes.
     */
    cursor?: MemoryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemoryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemoryNotes.
     */
    skip?: number
    distinct?: MemoryNoteScalarFieldEnum | MemoryNoteScalarFieldEnum[]
  }

  /**
   * MemoryNote create
   */
  export type MemoryNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a MemoryNote.
     */
    data: XOR<MemoryNoteCreateInput, MemoryNoteUncheckedCreateInput>
  }

  /**
   * MemoryNote createMany
   */
  export type MemoryNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemoryNotes.
     */
    data: MemoryNoteCreateManyInput | MemoryNoteCreateManyInput[]
  }

  /**
   * MemoryNote createManyAndReturn
   */
  export type MemoryNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * The data used to create many MemoryNotes.
     */
    data: MemoryNoteCreateManyInput | MemoryNoteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemoryNote update
   */
  export type MemoryNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a MemoryNote.
     */
    data: XOR<MemoryNoteUpdateInput, MemoryNoteUncheckedUpdateInput>
    /**
     * Choose, which MemoryNote to update.
     */
    where: MemoryNoteWhereUniqueInput
  }

  /**
   * MemoryNote updateMany
   */
  export type MemoryNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemoryNotes.
     */
    data: XOR<MemoryNoteUpdateManyMutationInput, MemoryNoteUncheckedUpdateManyInput>
    /**
     * Filter which MemoryNotes to update
     */
    where?: MemoryNoteWhereInput
    /**
     * Limit how many MemoryNotes to update.
     */
    limit?: number
  }

  /**
   * MemoryNote updateManyAndReturn
   */
  export type MemoryNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * The data used to update MemoryNotes.
     */
    data: XOR<MemoryNoteUpdateManyMutationInput, MemoryNoteUncheckedUpdateManyInput>
    /**
     * Filter which MemoryNotes to update
     */
    where?: MemoryNoteWhereInput
    /**
     * Limit how many MemoryNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemoryNote upsert
   */
  export type MemoryNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the MemoryNote to update in case it exists.
     */
    where: MemoryNoteWhereUniqueInput
    /**
     * In case the MemoryNote found by the `where` argument doesn't exist, create a new MemoryNote with this data.
     */
    create: XOR<MemoryNoteCreateInput, MemoryNoteUncheckedCreateInput>
    /**
     * In case the MemoryNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemoryNoteUpdateInput, MemoryNoteUncheckedUpdateInput>
  }

  /**
   * MemoryNote delete
   */
  export type MemoryNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
    /**
     * Filter which MemoryNote to delete.
     */
    where: MemoryNoteWhereUniqueInput
  }

  /**
   * MemoryNote deleteMany
   */
  export type MemoryNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemoryNotes to delete
     */
    where?: MemoryNoteWhereInput
    /**
     * Limit how many MemoryNotes to delete.
     */
    limit?: number
  }

  /**
   * MemoryNote without action
   */
  export type MemoryNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryNote
     */
    select?: MemoryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemoryNote
     */
    omit?: MemoryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryNoteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MemorialScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    birthDate: 'birthDate',
    deathDate: 'deathDate',
    obituaryNote: 'obituaryNote',
    bio: 'bio',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type MemorialScalarFieldEnum = (typeof MemorialScalarFieldEnum)[keyof typeof MemorialScalarFieldEnum]


  export const CeremonyScalarFieldEnum: {
    id: 'id',
    memorialId: 'memorialId',
    dateTime: 'dateTime',
    venue: 'venue',
    address: 'address',
    mapUrl: 'mapUrl',
    livestream: 'livestream'
  };

  export type CeremonyScalarFieldEnum = (typeof CeremonyScalarFieldEnum)[keyof typeof CeremonyScalarFieldEnum]


  export const ReceptionScalarFieldEnum: {
    id: 'id',
    memorialId: 'memorialId',
    dateTime: 'dateTime',
    venue: 'venue',
    address: 'address',
    mapUrl: 'mapUrl',
    welcomeScope: 'welcomeScope',
    wishes: 'wishes'
  };

  export type ReceptionScalarFieldEnum = (typeof ReceptionScalarFieldEnum)[keyof typeof ReceptionScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    memorialId: 'memorialId',
    name: 'name',
    email: 'email',
    count: 'count',
    notes: 'notes',
    wantsToSpeak: 'wantsToSpeak',
    relationsJson: 'relationsJson',
    createdAt: 'createdAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const MemoryNoteScalarFieldEnum: {
    id: 'id',
    memorialId: 'memorialId',
    author: 'author',
    text: 'text',
    approved: 'approved',
    createdAt: 'createdAt'
  };

  export type MemoryNoteScalarFieldEnum = (typeof MemoryNoteScalarFieldEnum)[keyof typeof MemoryNoteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'WelcomeScope'
   */
  export type EnumWelcomeScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WelcomeScope'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type MemorialWhereInput = {
    AND?: MemorialWhereInput | MemorialWhereInput[]
    OR?: MemorialWhereInput[]
    NOT?: MemorialWhereInput | MemorialWhereInput[]
    id?: IntFilter<"Memorial"> | number
    slug?: StringFilter<"Memorial"> | string
    name?: StringFilter<"Memorial"> | string
    birthDate?: DateTimeNullableFilter<"Memorial"> | Date | string | null
    deathDate?: DateTimeNullableFilter<"Memorial"> | Date | string | null
    obituaryNote?: StringNullableFilter<"Memorial"> | string | null
    bio?: StringNullableFilter<"Memorial"> | string | null
    imageUrl?: StringNullableFilter<"Memorial"> | string | null
    createdAt?: DateTimeFilter<"Memorial"> | Date | string
    ceremony?: XOR<CeremonyNullableScalarRelationFilter, CeremonyWhereInput> | null
    reception?: XOR<ReceptionNullableScalarRelationFilter, ReceptionWhereInput> | null
    notes?: MemoryNoteListRelationFilter
    attendances?: AttendanceListRelationFilter
  }

  export type MemorialOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    deathDate?: SortOrderInput | SortOrder
    obituaryNote?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ceremony?: CeremonyOrderByWithRelationInput
    reception?: ReceptionOrderByWithRelationInput
    notes?: MemoryNoteOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
  }

  export type MemorialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: MemorialWhereInput | MemorialWhereInput[]
    OR?: MemorialWhereInput[]
    NOT?: MemorialWhereInput | MemorialWhereInput[]
    name?: StringFilter<"Memorial"> | string
    birthDate?: DateTimeNullableFilter<"Memorial"> | Date | string | null
    deathDate?: DateTimeNullableFilter<"Memorial"> | Date | string | null
    obituaryNote?: StringNullableFilter<"Memorial"> | string | null
    bio?: StringNullableFilter<"Memorial"> | string | null
    imageUrl?: StringNullableFilter<"Memorial"> | string | null
    createdAt?: DateTimeFilter<"Memorial"> | Date | string
    ceremony?: XOR<CeremonyNullableScalarRelationFilter, CeremonyWhereInput> | null
    reception?: XOR<ReceptionNullableScalarRelationFilter, ReceptionWhereInput> | null
    notes?: MemoryNoteListRelationFilter
    attendances?: AttendanceListRelationFilter
  }, "id" | "slug">

  export type MemorialOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    deathDate?: SortOrderInput | SortOrder
    obituaryNote?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MemorialCountOrderByAggregateInput
    _avg?: MemorialAvgOrderByAggregateInput
    _max?: MemorialMaxOrderByAggregateInput
    _min?: MemorialMinOrderByAggregateInput
    _sum?: MemorialSumOrderByAggregateInput
  }

  export type MemorialScalarWhereWithAggregatesInput = {
    AND?: MemorialScalarWhereWithAggregatesInput | MemorialScalarWhereWithAggregatesInput[]
    OR?: MemorialScalarWhereWithAggregatesInput[]
    NOT?: MemorialScalarWhereWithAggregatesInput | MemorialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Memorial"> | number
    slug?: StringWithAggregatesFilter<"Memorial"> | string
    name?: StringWithAggregatesFilter<"Memorial"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"Memorial"> | Date | string | null
    deathDate?: DateTimeNullableWithAggregatesFilter<"Memorial"> | Date | string | null
    obituaryNote?: StringNullableWithAggregatesFilter<"Memorial"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Memorial"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Memorial"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Memorial"> | Date | string
  }

  export type CeremonyWhereInput = {
    AND?: CeremonyWhereInput | CeremonyWhereInput[]
    OR?: CeremonyWhereInput[]
    NOT?: CeremonyWhereInput | CeremonyWhereInput[]
    id?: IntFilter<"Ceremony"> | number
    memorialId?: IntFilter<"Ceremony"> | number
    dateTime?: DateTimeFilter<"Ceremony"> | Date | string
    venue?: StringFilter<"Ceremony"> | string
    address?: StringNullableFilter<"Ceremony"> | string | null
    mapUrl?: StringNullableFilter<"Ceremony"> | string | null
    livestream?: StringNullableFilter<"Ceremony"> | string | null
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }

  export type CeremonyOrderByWithRelationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrderInput | SortOrder
    mapUrl?: SortOrderInput | SortOrder
    livestream?: SortOrderInput | SortOrder
    Memorial?: MemorialOrderByWithRelationInput
  }

  export type CeremonyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    memorialId?: number
    AND?: CeremonyWhereInput | CeremonyWhereInput[]
    OR?: CeremonyWhereInput[]
    NOT?: CeremonyWhereInput | CeremonyWhereInput[]
    dateTime?: DateTimeFilter<"Ceremony"> | Date | string
    venue?: StringFilter<"Ceremony"> | string
    address?: StringNullableFilter<"Ceremony"> | string | null
    mapUrl?: StringNullableFilter<"Ceremony"> | string | null
    livestream?: StringNullableFilter<"Ceremony"> | string | null
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }, "id" | "memorialId">

  export type CeremonyOrderByWithAggregationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrderInput | SortOrder
    mapUrl?: SortOrderInput | SortOrder
    livestream?: SortOrderInput | SortOrder
    _count?: CeremonyCountOrderByAggregateInput
    _avg?: CeremonyAvgOrderByAggregateInput
    _max?: CeremonyMaxOrderByAggregateInput
    _min?: CeremonyMinOrderByAggregateInput
    _sum?: CeremonySumOrderByAggregateInput
  }

  export type CeremonyScalarWhereWithAggregatesInput = {
    AND?: CeremonyScalarWhereWithAggregatesInput | CeremonyScalarWhereWithAggregatesInput[]
    OR?: CeremonyScalarWhereWithAggregatesInput[]
    NOT?: CeremonyScalarWhereWithAggregatesInput | CeremonyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ceremony"> | number
    memorialId?: IntWithAggregatesFilter<"Ceremony"> | number
    dateTime?: DateTimeWithAggregatesFilter<"Ceremony"> | Date | string
    venue?: StringWithAggregatesFilter<"Ceremony"> | string
    address?: StringNullableWithAggregatesFilter<"Ceremony"> | string | null
    mapUrl?: StringNullableWithAggregatesFilter<"Ceremony"> | string | null
    livestream?: StringNullableWithAggregatesFilter<"Ceremony"> | string | null
  }

  export type ReceptionWhereInput = {
    AND?: ReceptionWhereInput | ReceptionWhereInput[]
    OR?: ReceptionWhereInput[]
    NOT?: ReceptionWhereInput | ReceptionWhereInput[]
    id?: IntFilter<"Reception"> | number
    memorialId?: IntFilter<"Reception"> | number
    dateTime?: DateTimeFilter<"Reception"> | Date | string
    venue?: StringFilter<"Reception"> | string
    address?: StringNullableFilter<"Reception"> | string | null
    mapUrl?: StringNullableFilter<"Reception"> | string | null
    welcomeScope?: EnumWelcomeScopeFilter<"Reception"> | $Enums.WelcomeScope
    wishes?: StringNullableFilter<"Reception"> | string | null
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }

  export type ReceptionOrderByWithRelationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrderInput | SortOrder
    mapUrl?: SortOrderInput | SortOrder
    welcomeScope?: SortOrder
    wishes?: SortOrderInput | SortOrder
    Memorial?: MemorialOrderByWithRelationInput
  }

  export type ReceptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    memorialId?: number
    AND?: ReceptionWhereInput | ReceptionWhereInput[]
    OR?: ReceptionWhereInput[]
    NOT?: ReceptionWhereInput | ReceptionWhereInput[]
    dateTime?: DateTimeFilter<"Reception"> | Date | string
    venue?: StringFilter<"Reception"> | string
    address?: StringNullableFilter<"Reception"> | string | null
    mapUrl?: StringNullableFilter<"Reception"> | string | null
    welcomeScope?: EnumWelcomeScopeFilter<"Reception"> | $Enums.WelcomeScope
    wishes?: StringNullableFilter<"Reception"> | string | null
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }, "id" | "memorialId">

  export type ReceptionOrderByWithAggregationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrderInput | SortOrder
    mapUrl?: SortOrderInput | SortOrder
    welcomeScope?: SortOrder
    wishes?: SortOrderInput | SortOrder
    _count?: ReceptionCountOrderByAggregateInput
    _avg?: ReceptionAvgOrderByAggregateInput
    _max?: ReceptionMaxOrderByAggregateInput
    _min?: ReceptionMinOrderByAggregateInput
    _sum?: ReceptionSumOrderByAggregateInput
  }

  export type ReceptionScalarWhereWithAggregatesInput = {
    AND?: ReceptionScalarWhereWithAggregatesInput | ReceptionScalarWhereWithAggregatesInput[]
    OR?: ReceptionScalarWhereWithAggregatesInput[]
    NOT?: ReceptionScalarWhereWithAggregatesInput | ReceptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reception"> | number
    memorialId?: IntWithAggregatesFilter<"Reception"> | number
    dateTime?: DateTimeWithAggregatesFilter<"Reception"> | Date | string
    venue?: StringWithAggregatesFilter<"Reception"> | string
    address?: StringNullableWithAggregatesFilter<"Reception"> | string | null
    mapUrl?: StringNullableWithAggregatesFilter<"Reception"> | string | null
    welcomeScope?: EnumWelcomeScopeWithAggregatesFilter<"Reception"> | $Enums.WelcomeScope
    wishes?: StringNullableWithAggregatesFilter<"Reception"> | string | null
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: IntFilter<"Attendance"> | number
    memorialId?: IntFilter<"Attendance"> | number
    name?: StringFilter<"Attendance"> | string
    email?: StringFilter<"Attendance"> | string
    count?: IntFilter<"Attendance"> | number
    notes?: StringNullableFilter<"Attendance"> | string | null
    wantsToSpeak?: BoolFilter<"Attendance"> | boolean
    relationsJson?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    count?: SortOrder
    notes?: SortOrderInput | SortOrder
    wantsToSpeak?: SortOrder
    relationsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Memorial?: MemorialOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    memorialId?: IntFilter<"Attendance"> | number
    name?: StringFilter<"Attendance"> | string
    email?: StringFilter<"Attendance"> | string
    count?: IntFilter<"Attendance"> | number
    notes?: StringNullableFilter<"Attendance"> | string | null
    wantsToSpeak?: BoolFilter<"Attendance"> | boolean
    relationsJson?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    count?: SortOrder
    notes?: SortOrderInput | SortOrder
    wantsToSpeak?: SortOrder
    relationsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attendance"> | number
    memorialId?: IntWithAggregatesFilter<"Attendance"> | number
    name?: StringWithAggregatesFilter<"Attendance"> | string
    email?: StringWithAggregatesFilter<"Attendance"> | string
    count?: IntWithAggregatesFilter<"Attendance"> | number
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    wantsToSpeak?: BoolWithAggregatesFilter<"Attendance"> | boolean
    relationsJson?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type MemoryNoteWhereInput = {
    AND?: MemoryNoteWhereInput | MemoryNoteWhereInput[]
    OR?: MemoryNoteWhereInput[]
    NOT?: MemoryNoteWhereInput | MemoryNoteWhereInput[]
    id?: IntFilter<"MemoryNote"> | number
    memorialId?: IntFilter<"MemoryNote"> | number
    author?: StringFilter<"MemoryNote"> | string
    text?: StringFilter<"MemoryNote"> | string
    approved?: BoolFilter<"MemoryNote"> | boolean
    createdAt?: DateTimeFilter<"MemoryNote"> | Date | string
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }

  export type MemoryNoteOrderByWithRelationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    author?: SortOrder
    text?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    Memorial?: MemorialOrderByWithRelationInput
  }

  export type MemoryNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MemoryNoteWhereInput | MemoryNoteWhereInput[]
    OR?: MemoryNoteWhereInput[]
    NOT?: MemoryNoteWhereInput | MemoryNoteWhereInput[]
    memorialId?: IntFilter<"MemoryNote"> | number
    author?: StringFilter<"MemoryNote"> | string
    text?: StringFilter<"MemoryNote"> | string
    approved?: BoolFilter<"MemoryNote"> | boolean
    createdAt?: DateTimeFilter<"MemoryNote"> | Date | string
    Memorial?: XOR<MemorialScalarRelationFilter, MemorialWhereInput>
  }, "id">

  export type MemoryNoteOrderByWithAggregationInput = {
    id?: SortOrder
    memorialId?: SortOrder
    author?: SortOrder
    text?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    _count?: MemoryNoteCountOrderByAggregateInput
    _avg?: MemoryNoteAvgOrderByAggregateInput
    _max?: MemoryNoteMaxOrderByAggregateInput
    _min?: MemoryNoteMinOrderByAggregateInput
    _sum?: MemoryNoteSumOrderByAggregateInput
  }

  export type MemoryNoteScalarWhereWithAggregatesInput = {
    AND?: MemoryNoteScalarWhereWithAggregatesInput | MemoryNoteScalarWhereWithAggregatesInput[]
    OR?: MemoryNoteScalarWhereWithAggregatesInput[]
    NOT?: MemoryNoteScalarWhereWithAggregatesInput | MemoryNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MemoryNote"> | number
    memorialId?: IntWithAggregatesFilter<"MemoryNote"> | number
    author?: StringWithAggregatesFilter<"MemoryNote"> | string
    text?: StringWithAggregatesFilter<"MemoryNote"> | string
    approved?: BoolWithAggregatesFilter<"MemoryNote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MemoryNote"> | Date | string
  }

  export type MemorialCreateInput = {
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyCreateNestedOneWithoutMemorialInput
    reception?: ReceptionCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteCreateNestedManyWithoutMemorialInput
    attendances?: AttendanceCreateNestedManyWithoutMemorialInput
  }

  export type MemorialUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyUncheckedCreateNestedOneWithoutMemorialInput
    reception?: ReceptionUncheckedCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteUncheckedCreateNestedManyWithoutMemorialInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMemorialInput
  }

  export type MemorialUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUpdateOneWithoutMemorialNestedInput
    reception?: ReceptionUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUpdateManyWithoutMemorialNestedInput
    attendances?: AttendanceUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUncheckedUpdateOneWithoutMemorialNestedInput
    reception?: ReceptionUncheckedUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUncheckedUpdateManyWithoutMemorialNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialCreateManyInput = {
    id?: number
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type MemorialUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemorialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CeremonyCreateInput = {
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    livestream?: string | null
    Memorial: MemorialCreateNestedOneWithoutCeremonyInput
  }

  export type CeremonyUncheckedCreateInput = {
    id?: number
    memorialId: number
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    livestream?: string | null
  }

  export type CeremonyUpdateInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    livestream?: NullableStringFieldUpdateOperationsInput | string | null
    Memorial?: MemorialUpdateOneRequiredWithoutCeremonyNestedInput
  }

  export type CeremonyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    livestream?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CeremonyCreateManyInput = {
    id?: number
    memorialId: number
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    livestream?: string | null
  }

  export type CeremonyUpdateManyMutationInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    livestream?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CeremonyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    livestream?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionCreateInput = {
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    welcomeScope?: $Enums.WelcomeScope
    wishes?: string | null
    Memorial: MemorialCreateNestedOneWithoutReceptionInput
  }

  export type ReceptionUncheckedCreateInput = {
    id?: number
    memorialId: number
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    welcomeScope?: $Enums.WelcomeScope
    wishes?: string | null
  }

  export type ReceptionUpdateInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeScope?: EnumWelcomeScopeFieldUpdateOperationsInput | $Enums.WelcomeScope
    wishes?: NullableStringFieldUpdateOperationsInput | string | null
    Memorial?: MemorialUpdateOneRequiredWithoutReceptionNestedInput
  }

  export type ReceptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeScope?: EnumWelcomeScopeFieldUpdateOperationsInput | $Enums.WelcomeScope
    wishes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionCreateManyInput = {
    id?: number
    memorialId: number
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    welcomeScope?: $Enums.WelcomeScope
    wishes?: string | null
  }

  export type ReceptionUpdateManyMutationInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeScope?: EnumWelcomeScopeFieldUpdateOperationsInput | $Enums.WelcomeScope
    wishes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeScope?: EnumWelcomeScopeFieldUpdateOperationsInput | $Enums.WelcomeScope
    wishes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCreateInput = {
    name: string
    email: string
    count?: number
    notes?: string | null
    wantsToSpeak?: boolean
    relationsJson?: string | null
    createdAt?: Date | string
    Memorial: MemorialCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: number
    memorialId: number
    name: string
    email: string
    count?: number
    notes?: string | null
    wantsToSpeak?: boolean
    relationsJson?: string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wantsToSpeak?: BoolFieldUpdateOperationsInput | boolean
    relationsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Memorial?: MemorialUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wantsToSpeak?: BoolFieldUpdateOperationsInput | boolean
    relationsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: number
    memorialId: number
    name: string
    email: string
    count?: number
    notes?: string | null
    wantsToSpeak?: boolean
    relationsJson?: string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wantsToSpeak?: BoolFieldUpdateOperationsInput | boolean
    relationsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wantsToSpeak?: BoolFieldUpdateOperationsInput | boolean
    relationsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryNoteCreateInput = {
    author: string
    text: string
    approved?: boolean
    createdAt?: Date | string
    Memorial: MemorialCreateNestedOneWithoutNotesInput
  }

  export type MemoryNoteUncheckedCreateInput = {
    id?: number
    memorialId: number
    author: string
    text: string
    approved?: boolean
    createdAt?: Date | string
  }

  export type MemoryNoteUpdateInput = {
    author?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Memorial?: MemorialUpdateOneRequiredWithoutNotesNestedInput
  }

  export type MemoryNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryNoteCreateManyInput = {
    id?: number
    memorialId: number
    author: string
    text: string
    approved?: boolean
    createdAt?: Date | string
  }

  export type MemoryNoteUpdateManyMutationInput = {
    author?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memorialId?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CeremonyNullableScalarRelationFilter = {
    is?: CeremonyWhereInput | null
    isNot?: CeremonyWhereInput | null
  }

  export type ReceptionNullableScalarRelationFilter = {
    is?: ReceptionWhereInput | null
    isNot?: ReceptionWhereInput | null
  }

  export type MemoryNoteListRelationFilter = {
    every?: MemoryNoteWhereInput
    some?: MemoryNoteWhereInput
    none?: MemoryNoteWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MemoryNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemorialCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    deathDate?: SortOrder
    obituaryNote?: SortOrder
    bio?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MemorialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MemorialMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    deathDate?: SortOrder
    obituaryNote?: SortOrder
    bio?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MemorialMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    deathDate?: SortOrder
    obituaryNote?: SortOrder
    bio?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MemorialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type MemorialScalarRelationFilter = {
    is?: MemorialWhereInput
    isNot?: MemorialWhereInput
  }

  export type CeremonyCountOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrder
    mapUrl?: SortOrder
    livestream?: SortOrder
  }

  export type CeremonyAvgOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
  }

  export type CeremonyMaxOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrder
    mapUrl?: SortOrder
    livestream?: SortOrder
  }

  export type CeremonyMinOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrder
    mapUrl?: SortOrder
    livestream?: SortOrder
  }

  export type CeremonySumOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
  }

  export type EnumWelcomeScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.WelcomeScope | EnumWelcomeScopeFieldRefInput<$PrismaModel>
    in?: $Enums.WelcomeScope[]
    notIn?: $Enums.WelcomeScope[]
    not?: NestedEnumWelcomeScopeFilter<$PrismaModel> | $Enums.WelcomeScope
  }

  export type ReceptionCountOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrder
    mapUrl?: SortOrder
    welcomeScope?: SortOrder
    wishes?: SortOrder
  }

  export type ReceptionAvgOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
  }

  export type ReceptionMaxOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrder
    mapUrl?: SortOrder
    welcomeScope?: SortOrder
    wishes?: SortOrder
  }

  export type ReceptionMinOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    dateTime?: SortOrder
    venue?: SortOrder
    address?: SortOrder
    mapUrl?: SortOrder
    welcomeScope?: SortOrder
    wishes?: SortOrder
  }

  export type ReceptionSumOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
  }

  export type EnumWelcomeScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WelcomeScope | EnumWelcomeScopeFieldRefInput<$PrismaModel>
    in?: $Enums.WelcomeScope[]
    notIn?: $Enums.WelcomeScope[]
    not?: NestedEnumWelcomeScopeWithAggregatesFilter<$PrismaModel> | $Enums.WelcomeScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWelcomeScopeFilter<$PrismaModel>
    _max?: NestedEnumWelcomeScopeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    count?: SortOrder
    notes?: SortOrder
    wantsToSpeak?: SortOrder
    relationsJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    count?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    count?: SortOrder
    notes?: SortOrder
    wantsToSpeak?: SortOrder
    relationsJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    count?: SortOrder
    notes?: SortOrder
    wantsToSpeak?: SortOrder
    relationsJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    count?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MemoryNoteCountOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    author?: SortOrder
    text?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
  }

  export type MemoryNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
  }

  export type MemoryNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    author?: SortOrder
    text?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
  }

  export type MemoryNoteMinOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
    author?: SortOrder
    text?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
  }

  export type MemoryNoteSumOrderByAggregateInput = {
    id?: SortOrder
    memorialId?: SortOrder
  }

  export type CeremonyCreateNestedOneWithoutMemorialInput = {
    create?: XOR<CeremonyCreateWithoutMemorialInput, CeremonyUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: CeremonyCreateOrConnectWithoutMemorialInput
    connect?: CeremonyWhereUniqueInput
  }

  export type ReceptionCreateNestedOneWithoutMemorialInput = {
    create?: XOR<ReceptionCreateWithoutMemorialInput, ReceptionUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: ReceptionCreateOrConnectWithoutMemorialInput
    connect?: ReceptionWhereUniqueInput
  }

  export type MemoryNoteCreateNestedManyWithoutMemorialInput = {
    create?: XOR<MemoryNoteCreateWithoutMemorialInput, MemoryNoteUncheckedCreateWithoutMemorialInput> | MemoryNoteCreateWithoutMemorialInput[] | MemoryNoteUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: MemoryNoteCreateOrConnectWithoutMemorialInput | MemoryNoteCreateOrConnectWithoutMemorialInput[]
    createMany?: MemoryNoteCreateManyMemorialInputEnvelope
    connect?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutMemorialInput = {
    create?: XOR<AttendanceCreateWithoutMemorialInput, AttendanceUncheckedCreateWithoutMemorialInput> | AttendanceCreateWithoutMemorialInput[] | AttendanceUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMemorialInput | AttendanceCreateOrConnectWithoutMemorialInput[]
    createMany?: AttendanceCreateManyMemorialInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CeremonyUncheckedCreateNestedOneWithoutMemorialInput = {
    create?: XOR<CeremonyCreateWithoutMemorialInput, CeremonyUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: CeremonyCreateOrConnectWithoutMemorialInput
    connect?: CeremonyWhereUniqueInput
  }

  export type ReceptionUncheckedCreateNestedOneWithoutMemorialInput = {
    create?: XOR<ReceptionCreateWithoutMemorialInput, ReceptionUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: ReceptionCreateOrConnectWithoutMemorialInput
    connect?: ReceptionWhereUniqueInput
  }

  export type MemoryNoteUncheckedCreateNestedManyWithoutMemorialInput = {
    create?: XOR<MemoryNoteCreateWithoutMemorialInput, MemoryNoteUncheckedCreateWithoutMemorialInput> | MemoryNoteCreateWithoutMemorialInput[] | MemoryNoteUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: MemoryNoteCreateOrConnectWithoutMemorialInput | MemoryNoteCreateOrConnectWithoutMemorialInput[]
    createMany?: MemoryNoteCreateManyMemorialInputEnvelope
    connect?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutMemorialInput = {
    create?: XOR<AttendanceCreateWithoutMemorialInput, AttendanceUncheckedCreateWithoutMemorialInput> | AttendanceCreateWithoutMemorialInput[] | AttendanceUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMemorialInput | AttendanceCreateOrConnectWithoutMemorialInput[]
    createMany?: AttendanceCreateManyMemorialInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CeremonyUpdateOneWithoutMemorialNestedInput = {
    create?: XOR<CeremonyCreateWithoutMemorialInput, CeremonyUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: CeremonyCreateOrConnectWithoutMemorialInput
    upsert?: CeremonyUpsertWithoutMemorialInput
    disconnect?: CeremonyWhereInput | boolean
    delete?: CeremonyWhereInput | boolean
    connect?: CeremonyWhereUniqueInput
    update?: XOR<XOR<CeremonyUpdateToOneWithWhereWithoutMemorialInput, CeremonyUpdateWithoutMemorialInput>, CeremonyUncheckedUpdateWithoutMemorialInput>
  }

  export type ReceptionUpdateOneWithoutMemorialNestedInput = {
    create?: XOR<ReceptionCreateWithoutMemorialInput, ReceptionUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: ReceptionCreateOrConnectWithoutMemorialInput
    upsert?: ReceptionUpsertWithoutMemorialInput
    disconnect?: ReceptionWhereInput | boolean
    delete?: ReceptionWhereInput | boolean
    connect?: ReceptionWhereUniqueInput
    update?: XOR<XOR<ReceptionUpdateToOneWithWhereWithoutMemorialInput, ReceptionUpdateWithoutMemorialInput>, ReceptionUncheckedUpdateWithoutMemorialInput>
  }

  export type MemoryNoteUpdateManyWithoutMemorialNestedInput = {
    create?: XOR<MemoryNoteCreateWithoutMemorialInput, MemoryNoteUncheckedCreateWithoutMemorialInput> | MemoryNoteCreateWithoutMemorialInput[] | MemoryNoteUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: MemoryNoteCreateOrConnectWithoutMemorialInput | MemoryNoteCreateOrConnectWithoutMemorialInput[]
    upsert?: MemoryNoteUpsertWithWhereUniqueWithoutMemorialInput | MemoryNoteUpsertWithWhereUniqueWithoutMemorialInput[]
    createMany?: MemoryNoteCreateManyMemorialInputEnvelope
    set?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    disconnect?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    delete?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    connect?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    update?: MemoryNoteUpdateWithWhereUniqueWithoutMemorialInput | MemoryNoteUpdateWithWhereUniqueWithoutMemorialInput[]
    updateMany?: MemoryNoteUpdateManyWithWhereWithoutMemorialInput | MemoryNoteUpdateManyWithWhereWithoutMemorialInput[]
    deleteMany?: MemoryNoteScalarWhereInput | MemoryNoteScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutMemorialNestedInput = {
    create?: XOR<AttendanceCreateWithoutMemorialInput, AttendanceUncheckedCreateWithoutMemorialInput> | AttendanceCreateWithoutMemorialInput[] | AttendanceUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMemorialInput | AttendanceCreateOrConnectWithoutMemorialInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutMemorialInput | AttendanceUpsertWithWhereUniqueWithoutMemorialInput[]
    createMany?: AttendanceCreateManyMemorialInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutMemorialInput | AttendanceUpdateWithWhereUniqueWithoutMemorialInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutMemorialInput | AttendanceUpdateManyWithWhereWithoutMemorialInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CeremonyUncheckedUpdateOneWithoutMemorialNestedInput = {
    create?: XOR<CeremonyCreateWithoutMemorialInput, CeremonyUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: CeremonyCreateOrConnectWithoutMemorialInput
    upsert?: CeremonyUpsertWithoutMemorialInput
    disconnect?: CeremonyWhereInput | boolean
    delete?: CeremonyWhereInput | boolean
    connect?: CeremonyWhereUniqueInput
    update?: XOR<XOR<CeremonyUpdateToOneWithWhereWithoutMemorialInput, CeremonyUpdateWithoutMemorialInput>, CeremonyUncheckedUpdateWithoutMemorialInput>
  }

  export type ReceptionUncheckedUpdateOneWithoutMemorialNestedInput = {
    create?: XOR<ReceptionCreateWithoutMemorialInput, ReceptionUncheckedCreateWithoutMemorialInput>
    connectOrCreate?: ReceptionCreateOrConnectWithoutMemorialInput
    upsert?: ReceptionUpsertWithoutMemorialInput
    disconnect?: ReceptionWhereInput | boolean
    delete?: ReceptionWhereInput | boolean
    connect?: ReceptionWhereUniqueInput
    update?: XOR<XOR<ReceptionUpdateToOneWithWhereWithoutMemorialInput, ReceptionUpdateWithoutMemorialInput>, ReceptionUncheckedUpdateWithoutMemorialInput>
  }

  export type MemoryNoteUncheckedUpdateManyWithoutMemorialNestedInput = {
    create?: XOR<MemoryNoteCreateWithoutMemorialInput, MemoryNoteUncheckedCreateWithoutMemorialInput> | MemoryNoteCreateWithoutMemorialInput[] | MemoryNoteUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: MemoryNoteCreateOrConnectWithoutMemorialInput | MemoryNoteCreateOrConnectWithoutMemorialInput[]
    upsert?: MemoryNoteUpsertWithWhereUniqueWithoutMemorialInput | MemoryNoteUpsertWithWhereUniqueWithoutMemorialInput[]
    createMany?: MemoryNoteCreateManyMemorialInputEnvelope
    set?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    disconnect?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    delete?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    connect?: MemoryNoteWhereUniqueInput | MemoryNoteWhereUniqueInput[]
    update?: MemoryNoteUpdateWithWhereUniqueWithoutMemorialInput | MemoryNoteUpdateWithWhereUniqueWithoutMemorialInput[]
    updateMany?: MemoryNoteUpdateManyWithWhereWithoutMemorialInput | MemoryNoteUpdateManyWithWhereWithoutMemorialInput[]
    deleteMany?: MemoryNoteScalarWhereInput | MemoryNoteScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutMemorialNestedInput = {
    create?: XOR<AttendanceCreateWithoutMemorialInput, AttendanceUncheckedCreateWithoutMemorialInput> | AttendanceCreateWithoutMemorialInput[] | AttendanceUncheckedCreateWithoutMemorialInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutMemorialInput | AttendanceCreateOrConnectWithoutMemorialInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutMemorialInput | AttendanceUpsertWithWhereUniqueWithoutMemorialInput[]
    createMany?: AttendanceCreateManyMemorialInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutMemorialInput | AttendanceUpdateWithWhereUniqueWithoutMemorialInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutMemorialInput | AttendanceUpdateManyWithWhereWithoutMemorialInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type MemorialCreateNestedOneWithoutCeremonyInput = {
    create?: XOR<MemorialCreateWithoutCeremonyInput, MemorialUncheckedCreateWithoutCeremonyInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutCeremonyInput
    connect?: MemorialWhereUniqueInput
  }

  export type MemorialUpdateOneRequiredWithoutCeremonyNestedInput = {
    create?: XOR<MemorialCreateWithoutCeremonyInput, MemorialUncheckedCreateWithoutCeremonyInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutCeremonyInput
    upsert?: MemorialUpsertWithoutCeremonyInput
    connect?: MemorialWhereUniqueInput
    update?: XOR<XOR<MemorialUpdateToOneWithWhereWithoutCeremonyInput, MemorialUpdateWithoutCeremonyInput>, MemorialUncheckedUpdateWithoutCeremonyInput>
  }

  export type MemorialCreateNestedOneWithoutReceptionInput = {
    create?: XOR<MemorialCreateWithoutReceptionInput, MemorialUncheckedCreateWithoutReceptionInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutReceptionInput
    connect?: MemorialWhereUniqueInput
  }

  export type EnumWelcomeScopeFieldUpdateOperationsInput = {
    set?: $Enums.WelcomeScope
  }

  export type MemorialUpdateOneRequiredWithoutReceptionNestedInput = {
    create?: XOR<MemorialCreateWithoutReceptionInput, MemorialUncheckedCreateWithoutReceptionInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutReceptionInput
    upsert?: MemorialUpsertWithoutReceptionInput
    connect?: MemorialWhereUniqueInput
    update?: XOR<XOR<MemorialUpdateToOneWithWhereWithoutReceptionInput, MemorialUpdateWithoutReceptionInput>, MemorialUncheckedUpdateWithoutReceptionInput>
  }

  export type MemorialCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<MemorialCreateWithoutAttendancesInput, MemorialUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutAttendancesInput
    connect?: MemorialWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MemorialUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<MemorialCreateWithoutAttendancesInput, MemorialUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutAttendancesInput
    upsert?: MemorialUpsertWithoutAttendancesInput
    connect?: MemorialWhereUniqueInput
    update?: XOR<XOR<MemorialUpdateToOneWithWhereWithoutAttendancesInput, MemorialUpdateWithoutAttendancesInput>, MemorialUncheckedUpdateWithoutAttendancesInput>
  }

  export type MemorialCreateNestedOneWithoutNotesInput = {
    create?: XOR<MemorialCreateWithoutNotesInput, MemorialUncheckedCreateWithoutNotesInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutNotesInput
    connect?: MemorialWhereUniqueInput
  }

  export type MemorialUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<MemorialCreateWithoutNotesInput, MemorialUncheckedCreateWithoutNotesInput>
    connectOrCreate?: MemorialCreateOrConnectWithoutNotesInput
    upsert?: MemorialUpsertWithoutNotesInput
    connect?: MemorialWhereUniqueInput
    update?: XOR<XOR<MemorialUpdateToOneWithWhereWithoutNotesInput, MemorialUpdateWithoutNotesInput>, MemorialUncheckedUpdateWithoutNotesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumWelcomeScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.WelcomeScope | EnumWelcomeScopeFieldRefInput<$PrismaModel>
    in?: $Enums.WelcomeScope[]
    notIn?: $Enums.WelcomeScope[]
    not?: NestedEnumWelcomeScopeFilter<$PrismaModel> | $Enums.WelcomeScope
  }

  export type NestedEnumWelcomeScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WelcomeScope | EnumWelcomeScopeFieldRefInput<$PrismaModel>
    in?: $Enums.WelcomeScope[]
    notIn?: $Enums.WelcomeScope[]
    not?: NestedEnumWelcomeScopeWithAggregatesFilter<$PrismaModel> | $Enums.WelcomeScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWelcomeScopeFilter<$PrismaModel>
    _max?: NestedEnumWelcomeScopeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CeremonyCreateWithoutMemorialInput = {
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    livestream?: string | null
  }

  export type CeremonyUncheckedCreateWithoutMemorialInput = {
    id?: number
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    livestream?: string | null
  }

  export type CeremonyCreateOrConnectWithoutMemorialInput = {
    where: CeremonyWhereUniqueInput
    create: XOR<CeremonyCreateWithoutMemorialInput, CeremonyUncheckedCreateWithoutMemorialInput>
  }

  export type ReceptionCreateWithoutMemorialInput = {
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    welcomeScope?: $Enums.WelcomeScope
    wishes?: string | null
  }

  export type ReceptionUncheckedCreateWithoutMemorialInput = {
    id?: number
    dateTime: Date | string
    venue: string
    address?: string | null
    mapUrl?: string | null
    welcomeScope?: $Enums.WelcomeScope
    wishes?: string | null
  }

  export type ReceptionCreateOrConnectWithoutMemorialInput = {
    where: ReceptionWhereUniqueInput
    create: XOR<ReceptionCreateWithoutMemorialInput, ReceptionUncheckedCreateWithoutMemorialInput>
  }

  export type MemoryNoteCreateWithoutMemorialInput = {
    author: string
    text: string
    approved?: boolean
    createdAt?: Date | string
  }

  export type MemoryNoteUncheckedCreateWithoutMemorialInput = {
    id?: number
    author: string
    text: string
    approved?: boolean
    createdAt?: Date | string
  }

  export type MemoryNoteCreateOrConnectWithoutMemorialInput = {
    where: MemoryNoteWhereUniqueInput
    create: XOR<MemoryNoteCreateWithoutMemorialInput, MemoryNoteUncheckedCreateWithoutMemorialInput>
  }

  export type MemoryNoteCreateManyMemorialInputEnvelope = {
    data: MemoryNoteCreateManyMemorialInput | MemoryNoteCreateManyMemorialInput[]
  }

  export type AttendanceCreateWithoutMemorialInput = {
    name: string
    email: string
    count?: number
    notes?: string | null
    wantsToSpeak?: boolean
    relationsJson?: string | null
    createdAt?: Date | string
  }

  export type AttendanceUncheckedCreateWithoutMemorialInput = {
    id?: number
    name: string
    email: string
    count?: number
    notes?: string | null
    wantsToSpeak?: boolean
    relationsJson?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutMemorialInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutMemorialInput, AttendanceUncheckedCreateWithoutMemorialInput>
  }

  export type AttendanceCreateManyMemorialInputEnvelope = {
    data: AttendanceCreateManyMemorialInput | AttendanceCreateManyMemorialInput[]
  }

  export type CeremonyUpsertWithoutMemorialInput = {
    update: XOR<CeremonyUpdateWithoutMemorialInput, CeremonyUncheckedUpdateWithoutMemorialInput>
    create: XOR<CeremonyCreateWithoutMemorialInput, CeremonyUncheckedCreateWithoutMemorialInput>
    where?: CeremonyWhereInput
  }

  export type CeremonyUpdateToOneWithWhereWithoutMemorialInput = {
    where?: CeremonyWhereInput
    data: XOR<CeremonyUpdateWithoutMemorialInput, CeremonyUncheckedUpdateWithoutMemorialInput>
  }

  export type CeremonyUpdateWithoutMemorialInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    livestream?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CeremonyUncheckedUpdateWithoutMemorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    livestream?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionUpsertWithoutMemorialInput = {
    update: XOR<ReceptionUpdateWithoutMemorialInput, ReceptionUncheckedUpdateWithoutMemorialInput>
    create: XOR<ReceptionCreateWithoutMemorialInput, ReceptionUncheckedCreateWithoutMemorialInput>
    where?: ReceptionWhereInput
  }

  export type ReceptionUpdateToOneWithWhereWithoutMemorialInput = {
    where?: ReceptionWhereInput
    data: XOR<ReceptionUpdateWithoutMemorialInput, ReceptionUncheckedUpdateWithoutMemorialInput>
  }

  export type ReceptionUpdateWithoutMemorialInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeScope?: EnumWelcomeScopeFieldUpdateOperationsInput | $Enums.WelcomeScope
    wishes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionUncheckedUpdateWithoutMemorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    welcomeScope?: EnumWelcomeScopeFieldUpdateOperationsInput | $Enums.WelcomeScope
    wishes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemoryNoteUpsertWithWhereUniqueWithoutMemorialInput = {
    where: MemoryNoteWhereUniqueInput
    update: XOR<MemoryNoteUpdateWithoutMemorialInput, MemoryNoteUncheckedUpdateWithoutMemorialInput>
    create: XOR<MemoryNoteCreateWithoutMemorialInput, MemoryNoteUncheckedCreateWithoutMemorialInput>
  }

  export type MemoryNoteUpdateWithWhereUniqueWithoutMemorialInput = {
    where: MemoryNoteWhereUniqueInput
    data: XOR<MemoryNoteUpdateWithoutMemorialInput, MemoryNoteUncheckedUpdateWithoutMemorialInput>
  }

  export type MemoryNoteUpdateManyWithWhereWithoutMemorialInput = {
    where: MemoryNoteScalarWhereInput
    data: XOR<MemoryNoteUpdateManyMutationInput, MemoryNoteUncheckedUpdateManyWithoutMemorialInput>
  }

  export type MemoryNoteScalarWhereInput = {
    AND?: MemoryNoteScalarWhereInput | MemoryNoteScalarWhereInput[]
    OR?: MemoryNoteScalarWhereInput[]
    NOT?: MemoryNoteScalarWhereInput | MemoryNoteScalarWhereInput[]
    id?: IntFilter<"MemoryNote"> | number
    memorialId?: IntFilter<"MemoryNote"> | number
    author?: StringFilter<"MemoryNote"> | string
    text?: StringFilter<"MemoryNote"> | string
    approved?: BoolFilter<"MemoryNote"> | boolean
    createdAt?: DateTimeFilter<"MemoryNote"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutMemorialInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutMemorialInput, AttendanceUncheckedUpdateWithoutMemorialInput>
    create: XOR<AttendanceCreateWithoutMemorialInput, AttendanceUncheckedCreateWithoutMemorialInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutMemorialInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutMemorialInput, AttendanceUncheckedUpdateWithoutMemorialInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutMemorialInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutMemorialInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: IntFilter<"Attendance"> | number
    memorialId?: IntFilter<"Attendance"> | number
    name?: StringFilter<"Attendance"> | string
    email?: StringFilter<"Attendance"> | string
    count?: IntFilter<"Attendance"> | number
    notes?: StringNullableFilter<"Attendance"> | string | null
    wantsToSpeak?: BoolFilter<"Attendance"> | boolean
    relationsJson?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type MemorialCreateWithoutCeremonyInput = {
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    reception?: ReceptionCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteCreateNestedManyWithoutMemorialInput
    attendances?: AttendanceCreateNestedManyWithoutMemorialInput
  }

  export type MemorialUncheckedCreateWithoutCeremonyInput = {
    id?: number
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    reception?: ReceptionUncheckedCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteUncheckedCreateNestedManyWithoutMemorialInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMemorialInput
  }

  export type MemorialCreateOrConnectWithoutCeremonyInput = {
    where: MemorialWhereUniqueInput
    create: XOR<MemorialCreateWithoutCeremonyInput, MemorialUncheckedCreateWithoutCeremonyInput>
  }

  export type MemorialUpsertWithoutCeremonyInput = {
    update: XOR<MemorialUpdateWithoutCeremonyInput, MemorialUncheckedUpdateWithoutCeremonyInput>
    create: XOR<MemorialCreateWithoutCeremonyInput, MemorialUncheckedCreateWithoutCeremonyInput>
    where?: MemorialWhereInput
  }

  export type MemorialUpdateToOneWithWhereWithoutCeremonyInput = {
    where?: MemorialWhereInput
    data: XOR<MemorialUpdateWithoutCeremonyInput, MemorialUncheckedUpdateWithoutCeremonyInput>
  }

  export type MemorialUpdateWithoutCeremonyInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reception?: ReceptionUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUpdateManyWithoutMemorialNestedInput
    attendances?: AttendanceUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialUncheckedUpdateWithoutCeremonyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reception?: ReceptionUncheckedUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUncheckedUpdateManyWithoutMemorialNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialCreateWithoutReceptionInput = {
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteCreateNestedManyWithoutMemorialInput
    attendances?: AttendanceCreateNestedManyWithoutMemorialInput
  }

  export type MemorialUncheckedCreateWithoutReceptionInput = {
    id?: number
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyUncheckedCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteUncheckedCreateNestedManyWithoutMemorialInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMemorialInput
  }

  export type MemorialCreateOrConnectWithoutReceptionInput = {
    where: MemorialWhereUniqueInput
    create: XOR<MemorialCreateWithoutReceptionInput, MemorialUncheckedCreateWithoutReceptionInput>
  }

  export type MemorialUpsertWithoutReceptionInput = {
    update: XOR<MemorialUpdateWithoutReceptionInput, MemorialUncheckedUpdateWithoutReceptionInput>
    create: XOR<MemorialCreateWithoutReceptionInput, MemorialUncheckedCreateWithoutReceptionInput>
    where?: MemorialWhereInput
  }

  export type MemorialUpdateToOneWithWhereWithoutReceptionInput = {
    where?: MemorialWhereInput
    data: XOR<MemorialUpdateWithoutReceptionInput, MemorialUncheckedUpdateWithoutReceptionInput>
  }

  export type MemorialUpdateWithoutReceptionInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUpdateManyWithoutMemorialNestedInput
    attendances?: AttendanceUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialUncheckedUpdateWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUncheckedUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUncheckedUpdateManyWithoutMemorialNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialCreateWithoutAttendancesInput = {
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyCreateNestedOneWithoutMemorialInput
    reception?: ReceptionCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteCreateNestedManyWithoutMemorialInput
  }

  export type MemorialUncheckedCreateWithoutAttendancesInput = {
    id?: number
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyUncheckedCreateNestedOneWithoutMemorialInput
    reception?: ReceptionUncheckedCreateNestedOneWithoutMemorialInput
    notes?: MemoryNoteUncheckedCreateNestedManyWithoutMemorialInput
  }

  export type MemorialCreateOrConnectWithoutAttendancesInput = {
    where: MemorialWhereUniqueInput
    create: XOR<MemorialCreateWithoutAttendancesInput, MemorialUncheckedCreateWithoutAttendancesInput>
  }

  export type MemorialUpsertWithoutAttendancesInput = {
    update: XOR<MemorialUpdateWithoutAttendancesInput, MemorialUncheckedUpdateWithoutAttendancesInput>
    create: XOR<MemorialCreateWithoutAttendancesInput, MemorialUncheckedCreateWithoutAttendancesInput>
    where?: MemorialWhereInput
  }

  export type MemorialUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: MemorialWhereInput
    data: XOR<MemorialUpdateWithoutAttendancesInput, MemorialUncheckedUpdateWithoutAttendancesInput>
  }

  export type MemorialUpdateWithoutAttendancesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUpdateOneWithoutMemorialNestedInput
    reception?: ReceptionUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialUncheckedUpdateWithoutAttendancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUncheckedUpdateOneWithoutMemorialNestedInput
    reception?: ReceptionUncheckedUpdateOneWithoutMemorialNestedInput
    notes?: MemoryNoteUncheckedUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialCreateWithoutNotesInput = {
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyCreateNestedOneWithoutMemorialInput
    reception?: ReceptionCreateNestedOneWithoutMemorialInput
    attendances?: AttendanceCreateNestedManyWithoutMemorialInput
  }

  export type MemorialUncheckedCreateWithoutNotesInput = {
    id?: number
    slug: string
    name: string
    birthDate?: Date | string | null
    deathDate?: Date | string | null
    obituaryNote?: string | null
    bio?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    ceremony?: CeremonyUncheckedCreateNestedOneWithoutMemorialInput
    reception?: ReceptionUncheckedCreateNestedOneWithoutMemorialInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutMemorialInput
  }

  export type MemorialCreateOrConnectWithoutNotesInput = {
    where: MemorialWhereUniqueInput
    create: XOR<MemorialCreateWithoutNotesInput, MemorialUncheckedCreateWithoutNotesInput>
  }

  export type MemorialUpsertWithoutNotesInput = {
    update: XOR<MemorialUpdateWithoutNotesInput, MemorialUncheckedUpdateWithoutNotesInput>
    create: XOR<MemorialCreateWithoutNotesInput, MemorialUncheckedCreateWithoutNotesInput>
    where?: MemorialWhereInput
  }

  export type MemorialUpdateToOneWithWhereWithoutNotesInput = {
    where?: MemorialWhereInput
    data: XOR<MemorialUpdateWithoutNotesInput, MemorialUncheckedUpdateWithoutNotesInput>
  }

  export type MemorialUpdateWithoutNotesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUpdateOneWithoutMemorialNestedInput
    reception?: ReceptionUpdateOneWithoutMemorialNestedInput
    attendances?: AttendanceUpdateManyWithoutMemorialNestedInput
  }

  export type MemorialUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deathDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obituaryNote?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceremony?: CeremonyUncheckedUpdateOneWithoutMemorialNestedInput
    reception?: ReceptionUncheckedUpdateOneWithoutMemorialNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutMemorialNestedInput
  }

  export type MemoryNoteCreateManyMemorialInput = {
    id?: number
    author: string
    text: string
    approved?: boolean
    createdAt?: Date | string
  }

  export type AttendanceCreateManyMemorialInput = {
    id?: number
    name: string
    email: string
    count?: number
    notes?: string | null
    wantsToSpeak?: boolean
    relationsJson?: string | null
    createdAt?: Date | string
  }

  export type MemoryNoteUpdateWithoutMemorialInput = {
    author?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryNoteUncheckedUpdateWithoutMemorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryNoteUncheckedUpdateManyWithoutMemorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutMemorialInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wantsToSpeak?: BoolFieldUpdateOperationsInput | boolean
    relationsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateWithoutMemorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wantsToSpeak?: BoolFieldUpdateOperationsInput | boolean
    relationsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutMemorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wantsToSpeak?: BoolFieldUpdateOperationsInput | boolean
    relationsJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}